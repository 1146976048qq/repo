From 445467d7e5c603148ac9ecb80b4801417bce6270 Mon Sep 17 00:00:00 2001
From: Yichao Yu <yyc1992@gmail.com>
Date: Fri, 3 Mar 2017 22:16:12 -0500
Subject: [PATCH 2/3] Optimize `isassigned` and inline `jl_array_isassigned`.

---
 base/array.jl        |  7 ++++---
 src/ccall.cpp        | 29 +++++++++++++++++++++++++++++
 src/julia.h          |  2 ++
 src/julia_internal.h |  1 +
 4 files changed, 36 insertions(+), 3 deletions(-)

diff --git a/base/array.jl b/base/array.jl
index a7e28bb6f9..b1393d650e 100644
--- a/base/array.jl
+++ b/base/array.jl
@@ -87,9 +87,10 @@ elsize{T}(a::Array{T}) = isbits(T) ? sizeof(T) : sizeof(Ptr)
 sizeof(a::Array) = elsize(a) * length(a)
 
 function isassigned(a::Array, i::Int...)
-    ii = sub2ind(size(a), i...)
-    1 <= ii <= length(a) || return false
-    ccall(:jl_array_isassigned, Cint, (Any, UInt), a, ii-1) == 1
+    @_inline_meta
+    ii = (sub2ind(size(a), i...) % UInt) - 1
+    ii < length(a) % UInt || return false
+    ccall(:jl_array_isassigned, Cint, (Any, UInt), a, ii) == 1
 end
 
 ## copy ##
diff --git a/src/ccall.cpp b/src/ccall.cpp
index 51436ada49..f881411d39 100644
--- a/src/ccall.cpp
+++ b/src/ccall.cpp
@@ -1783,6 +1783,35 @@ static jl_cgval_t emit_ccall(jl_value_t **args, size_t nargs, jl_codectx_t *ctx)
         }
         JL_GC_POP();
     }
+    if ((fptr == (void(*)(void))&jl_array_isassigned ||
+         ((f_lib==NULL || (intptr_t)f_lib==2)
+          && f_name && !strcmp(f_name, "jl_array_isassigned"))) &&
+        expr_type(args[6], ctx) == (jl_value_t*)jl_ulong_type) {
+        assert(nargt == 2);
+        jl_value_t *aryex = args[4];
+        jl_value_t *idxex = args[6];
+        jl_value_t *aryty = expr_type(aryex, ctx);
+        if (jl_is_array_type(aryty)) {
+            jl_value_t *ety = jl_tparam0(aryty);
+            if (jl_isbits(ety)) {
+                emit_expr(aryex, ctx);
+                emit_expr(idxex, ctx);
+                JL_GC_POP();
+                return mark_or_box_ccall_result(ConstantInt::get(T_int32, 1),
+                                                false, rt, unionall, static_rt, ctx);
+            }
+            else if (!jl_has_free_typevars(ety)) { // TODO: jn/foreigncall branch has a better predicate
+                jl_cgval_t aryv = emit_expr(aryex, ctx);
+                Value *idx = emit_unbox(T_size, emit_expr(idxex, ctx), (jl_value_t*)jl_ulong_type);
+                Value *arrayptr = emit_bitcast(emit_arrayptr(aryv, aryex, ctx), T_ppjlvalue);
+                Value *slot_addr = builder.CreateGEP(arrayptr, idx);
+                Value *load = tbaa_decorate(tbaa_arraybuf, builder.CreateLoad(slot_addr));
+                Value *res = builder.CreateZExt(builder.CreateICmpNE(load, V_null), T_int32);
+                JL_GC_POP();
+                return mark_or_box_ccall_result(res, retboxed, rt, unionall, static_rt, ctx);
+            }
+        }
+    }
 
     // emit arguments
     jl_cgval_t *argv = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * (nargs - 3) / 2);
diff --git a/src/julia.h b/src/julia.h
index 9e3b6a2de6..3def1f10ee 100644
--- a/src/julia.h
+++ b/src/julia.h
@@ -1085,12 +1085,14 @@ JL_DLLEXPORT int jl_get_size(jl_value_t *val, size_t *pnt);
 #define jl_unbox_long(x) jl_unbox_int64(x)
 #define jl_is_long(x)    jl_is_int64(x)
 #define jl_long_type     jl_int64_type
+#define jl_ulong_type    jl_uint64_type
 #else
 #define jl_box_long(x)   jl_box_int32(x)
 #define jl_box_ulong(x)  jl_box_uint32(x)
 #define jl_unbox_long(x) jl_unbox_int32(x)
 #define jl_is_long(x)    jl_is_int32(x)
 #define jl_long_type     jl_int32_type
+#define jl_ulong_type    jl_uint32_type
 #endif
 
 // Each tuple can exist in one of 4 Vararg states:
diff --git a/src/julia_internal.h b/src/julia_internal.h
index e40cd82eea..015b740b5b 100644
--- a/src/julia_internal.h
+++ b/src/julia_internal.h
@@ -784,6 +784,7 @@ JL_DLLEXPORT jl_value_t *jl_arraylen(jl_value_t *a);
 int jl_array_store_unboxed(jl_value_t *el_type);
 int jl_array_isdefined(jl_value_t **args, int nargs);
 JL_DLLEXPORT jl_value_t *(jl_array_data_owner)(jl_array_t *a);
+JL_DLLEXPORT int jl_array_isassigned(jl_array_t *a, size_t i);
 
 // -- synchronization utilities -- //
 
-- 
2.12.2

