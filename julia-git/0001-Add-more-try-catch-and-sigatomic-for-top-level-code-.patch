From b6b257640bd3fbabb34e09b7d891fef899d248fe Mon Sep 17 00:00:00 2001
From: Yichao Yu <yyc1992@gmail.com>
Date: Sat, 30 Jul 2016 08:04:26 +0800
Subject: [PATCH 1/2] Add more `try`-`catch` and sigatomic for top-level
 code/new tasks

So that we don't need to run `jl_exit` in strange (signal handler) context
due to missing exception handler.
---
 base/task.jl |  3 +++
 src/julia.h  |  1 +
 src/task.c   | 22 ++++++++++++++++------
 ui/repl.c    |  7 ++++++-
 4 files changed, 26 insertions(+), 7 deletions(-)

diff --git a/base/task.jl b/base/task.jl
index 148b778..38b98d6 100644
--- a/base/task.jl
+++ b/base/task.jl
@@ -105,6 +105,7 @@ suppress_excp_printing(t::Task) = isa(t.storage, ObjectIdDict) ? get(get_task_tl
 
 # runtime system hook called when a task finishes
 function task_done_hook(t::Task)
+    # `finish_task` sets `sigatomic` before entering this function
     err = (t.state == :failed)
     result = t.result
     handled = false
@@ -152,6 +153,8 @@ function task_done_hook(t::Task)
             end
         end
     end
+    # Clear sigatomic before waiting
+    sigatomic_end()
     wait()
 end
 
diff --git a/src/julia.h b/src/julia.h
index 3e3b228..5ee5991 100644
--- a/src/julia.h
+++ b/src/julia.h
@@ -1465,6 +1465,7 @@ JL_DLLEXPORT jl_value_t *jl_switchto(jl_task_t *t, jl_value_t *arg);
 JL_DLLEXPORT void JL_NORETURN jl_throw(jl_value_t *e);
 JL_DLLEXPORT void JL_NORETURN jl_rethrow(void);
 JL_DLLEXPORT void JL_NORETURN jl_rethrow_other(jl_value_t *e);
+JL_DLLEXPORT void JL_NORETURN jl_no_exc_handler(jl_value_t *e);
 
 #ifdef JULIA_ENABLE_THREADING
 static inline void jl_lock_frame_push(jl_mutex_t *lock)
diff --git a/src/task.c b/src/task.c
index b1cf229..105e80d 100644
--- a/src/task.c
+++ b/src/task.c
@@ -188,6 +188,7 @@ static jl_function_t *task_done_hook_func=NULL;
 static void JL_NORETURN finish_task(jl_task_t *t, jl_value_t *resultval)
 {
     jl_ptls_t ptls = jl_get_ptls_states();
+    JL_SIGATOMIC_BEGIN();
     if (t->exception != jl_nothing)
         t->state = failed_sym;
     else
@@ -211,7 +212,12 @@ static void JL_NORETURN finish_task(jl_task_t *t, jl_value_t *resultval)
     }
     if (task_done_hook_func != NULL) {
         jl_value_t *args[2] = {task_done_hook_func, (jl_value_t*)t};
-        jl_apply(args, 2);
+        JL_TRY {
+            jl_apply(args, 2);
+        }
+        JL_CATCH {
+            jl_no_exc_handler(jl_exception_in_transit);
+        }
     }
     gc_debug_critical_error();
     abort();
@@ -509,6 +515,14 @@ static void init_task(jl_task_t *t, char *stack)
 #endif /* !COPY_STACKS */
 
 jl_timing_block_t *jl_pop_timing_block(jl_timing_block_t *cur_block);
+JL_DLLEXPORT JL_NORETURN void jl_no_exc_handler(jl_value_t *e)
+{
+    jl_printf(JL_STDERR, "fatal: error thrown and no exception handler available.\n");
+    jl_static_show(JL_STDERR, e);
+    jl_printf(JL_STDERR, "\n");
+    jlbacktrace();
+    jl_exit(1);
+}
 
 // yield to exception handler
 void JL_NORETURN throw_internal(jl_value_t *e)
@@ -532,11 +546,7 @@ void JL_NORETURN throw_internal(jl_value_t *e)
         jl_longjmp(eh->eh_ctx, 1);
     }
     else {
-        jl_printf(JL_STDERR, "fatal: error thrown and no exception handler available.\n");
-        jl_static_show(JL_STDERR, e);
-        jl_printf(JL_STDERR, "\n");
-        jlbacktrace();
-        jl_exit(1);
+        jl_no_exc_handler(e);
     }
     assert(0);
 }
diff --git a/ui/repl.c b/ui/repl.c
index b0ae9c0..826d23f 100644
--- a/ui/repl.c
+++ b/ui/repl.c
@@ -109,7 +109,12 @@ static NOINLINE int true_main(int argc, char *argv[])
         (jl_function_t*)jl_get_global(jl_base_module, jl_symbol("_start")) : NULL;
 
     if (start_client) {
-        jl_apply(&start_client, 1);
+        JL_TRY {
+            jl_apply(&start_client, 1);
+        }
+        JL_CATCH {
+            jl_no_exc_handler(jl_exception_in_transit);
+        }
         return 0;
     }
 
-- 
2.9.0

