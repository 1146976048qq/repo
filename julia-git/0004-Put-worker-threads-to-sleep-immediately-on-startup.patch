From 795805f2b88ce4d8368dee16d4b1c0b4277133bf Mon Sep 17 00:00:00 2001
From: Yichao Yu <yyc1992@gmail.com>
Date: Fri, 21 Apr 2017 12:51:11 -0400
Subject: [PATCH 4/4] Put worker threads to sleep immediately on startup

---
 src/threadgroup.c | 5 +++--
 src/threadgroup.h | 2 +-
 src/threading.c   | 9 ++++++---
 3 files changed, 10 insertions(+), 6 deletions(-)

diff --git a/src/threadgroup.c b/src/threadgroup.c
index 57e995065a..038e92d925 100644
--- a/src/threadgroup.c
+++ b/src/threadgroup.c
@@ -116,7 +116,7 @@ int ti_threadgroup_size(ti_threadgroup_t *tg, int16_t *tgsize)
     return 0;
 }
 
-int ti_threadgroup_fork(ti_threadgroup_t *tg, int16_t ext_tid, void **bcast_val)
+int ti_threadgroup_fork(ti_threadgroup_t *tg, int16_t ext_tid, void **bcast_val, int init)
 {
     uint8_t *group_sense = &tg->group_sense;
     int16_t tid = tg->tid_map[ext_tid];
@@ -147,13 +147,14 @@ int ti_threadgroup_fork(ti_threadgroup_t *tg, int16_t ext_tid, void **bcast_val)
                 }
                 spin_ns = uv_hrtime() - spin_start;
                 // In case uv_hrtime is not monotonic, we'll sleep earlier
-                if (spin_ns >= tg->sleep_threshold) {
+                if (init || spin_ns >= tg->sleep_threshold) {
                     uv_mutex_lock(&tg->alarm_lock);
                     if (jl_atomic_load_acquire(group_sense) != thread_sense) {
                         uv_cond_wait(&tg->alarm, &tg->alarm_lock);
                     }
                     uv_mutex_unlock(&tg->alarm_lock);
                     spin_start = 0;
+                    init = 0;
                     continue;
                 }
             }
diff --git a/src/threadgroup.h b/src/threadgroup.h
index 72e76d2dcf..9ab7618e0e 100644
--- a/src/threadgroup.h
+++ b/src/threadgroup.h
@@ -37,7 +37,7 @@ int ti_threadgroup_member(ti_threadgroup_t *tg, int16_t ext_tid,
                           int16_t *tgtid);
 int ti_threadgroup_size(ti_threadgroup_t *tg, int16_t *tgsize);
 int ti_threadgroup_fork(ti_threadgroup_t *tg, int16_t ext_tid,
-                        void **bcast_val);
+                        void **bcast_val, int init);
 int ti_threadgroup_join(ti_threadgroup_t *tg, int16_t ext_tid);
 int ti_threadgroup_destroy(ti_threadgroup_t *tg);
 
diff --git a/src/threading.c b/src/threading.c
index f2fdaf96eb..8d37459a68 100644
--- a/src/threading.c
+++ b/src/threading.c
@@ -391,13 +391,16 @@ void ti_threadfun(void *arg)
     // free the thread argument here
     free(ta);
 
+    int init = 1;
+
     // work loop
     for (; ;) {
 #if PROFILE_JL_THREADING
         uint64_t tstart = uv_hrtime();
 #endif
 
-        ti_threadgroup_fork(tg, ptls->tid, (void **)&work);
+        ti_threadgroup_fork(tg, ptls->tid, (void **)&work, init);
+        init = 0;
 
 #if PROFILE_JL_THREADING
         uint64_t tfork = uv_hrtime();
@@ -645,7 +648,7 @@ void jl_shutdown_threading(void)
     ti_threadwork_t *work = &threadwork;
 
     work->command = TI_THREADWORK_DONE;
-    ti_threadgroup_fork(tgworld, ptls->tid, (void **)&work);
+    ti_threadgroup_fork(tgworld, ptls->tid, (void **)&work, 0);
 
     sleep(1);
 
@@ -704,7 +707,7 @@ JL_DLLEXPORT jl_value_t *jl_threading_run(jl_value_t *_args)
 
     // fork the world thread group
     ti_threadwork_t *tw = &threadwork;
-    ti_threadgroup_fork(tgworld, ptls->tid, (void **)&tw);
+    ti_threadgroup_fork(tgworld, ptls->tid, (void **)&tw, 0);
 
 #if PROFILE_JL_THREADING
     uint64_t tfork = uv_hrtime();
-- 
2.12.2

