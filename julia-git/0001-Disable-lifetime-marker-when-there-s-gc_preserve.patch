From c4e64e001abcd4f8b806096c23c101872a82857c Mon Sep 17 00:00:00 2001
From: Yichao Yu <yyc1992@gmail.com>
Date: Fri, 22 Sep 2017 21:43:29 -0400
Subject: [PATCH] Disable lifetime marker when there's gc_preserve

In this case, the lifetime is not just determined by the instructions we see anymore.
As a quick fix, disable lifetime marker before we have a slightly fancier version that keeps
track of the real lifetime.
---
 src/llvm-alloc-opt.cpp | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/src/llvm-alloc-opt.cpp b/src/llvm-alloc-opt.cpp
index 582dccab62..f53d0a9d82 100644
--- a/src/llvm-alloc-opt.cpp
+++ b/src/llvm-alloc-opt.cpp
@@ -151,7 +151,7 @@ private:
     bool doInitialization(Module &m) override;
     bool runOnFunction(Function &F) override;
     bool checkInst(Instruction *I, CheckInstStack &stack, std::set<Instruction*> &uses,
-                   bool &ignore_tag);
+                   bool &ignore_tag, bool &has_preserve);
     void replaceUsesWith(Instruction *orig_i, Instruction *new_i, ReplaceUsesStack &stack);
     void replaceIntrinsicUseWith(IntrinsicInst *call, Intrinsic::ID ID, Instruction *orig_i,
                                  Instruction *new_i);
@@ -366,7 +366,7 @@ bool AllocOpt::doInitialization(Module &M)
 }
 
 bool AllocOpt::checkInst(Instruction *I, CheckInstStack &stack, std::set<Instruction*> &uses,
-                         bool &ignore_tag)
+                         bool &ignore_tag, bool &has_preserve)
 {
     uses.clear();
     if (I->use_empty())
@@ -395,6 +395,7 @@ bool AllocOpt::checkInst(Instruction *I, CheckInstStack &stack, std::set<Instruc
                     return true;
                 }
                 if (gc_preserve_begin && gc_preserve_begin == callee) {
+                    has_preserve = true;
                     return true;
                 }
             }
@@ -657,9 +658,10 @@ bool AllocOpt::runOnFunction(Function &F)
     LifetimeMarker lifetime(*this);
     for (auto &it: allocs) {
         bool ignore_tag = true;
+        bool has_preserve = false;
         auto orig = it.first;
         size_t &sz = it.second;
-        if (!checkInst(orig, check_stack, alloc_uses, ignore_tag)) {
+        if (!checkInst(orig, check_stack, alloc_uses, ignore_tag, has_preserve)) {
             sz = UINT32_MAX;
             continue;
         }
@@ -692,7 +694,9 @@ bool AllocOpt::runOnFunction(Function &F)
             buff->setAlignment(align);
             ptr = cast<Instruction>(prolog_builder.CreateBitCast(buff, T_pint8));
         }
-        lifetime.insert(ptr, ConstantInt::get(T_int64, sz), orig, alloc_uses);
+        // TODO: if there's gc_preserve_begin, keep track of the lifetime properly
+        if (!has_preserve)
+            lifetime.insert(ptr, ConstantInt::get(T_int64, sz), orig, alloc_uses);
         // Someone might be reading the tag, initialize it.
         if (!ignore_tag) {
             ptr = cast<Instruction>(prolog_builder.CreateConstGEP1_32(T_int8, ptr, align));
-- 
2.14.1

