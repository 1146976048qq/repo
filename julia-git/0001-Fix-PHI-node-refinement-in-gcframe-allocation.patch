From ff6d107b2914fde47bc8d036145d695a75c70443 Mon Sep 17 00:00:00 2001
From: Yichao Yu <yyc1992@gmail.com>
Date: Thu, 12 Oct 2017 11:51:46 -0400
Subject: [PATCH 1/2] Fix PHI node refinement in gcframe allocation

* Make sure the refinement values all dominate the value itself
  Propagate externally rooted values and relax invalid incoming values
  to their refinements when possible.

* Also have better handling of values that aren't used but are live.
---
 src/llvm-late-gc-lowering.cpp  | 280 +++++++++++++++++++++++++++++++++--------
 test/codegen.jl                |  20 ++-
 test/llvmpasses/gcroots.ll     |  21 ----
 test/llvmpasses/refinements.ll | 110 ++++++++++++++++
 4 files changed, 351 insertions(+), 80 deletions(-)

diff --git a/src/llvm-late-gc-lowering.cpp b/src/llvm-late-gc-lowering.cpp
index 389f04b6d1..a7a82f873e 100644
--- a/src/llvm-late-gc-lowering.cpp
+++ b/src/llvm-late-gc-lowering.cpp
@@ -237,6 +237,9 @@ struct BBState {
 };
 
 struct State {
+    Function *const F;
+    DominatorTree *DT;
+
     // The maximum assigned value number
     int MaxPtrNumber;
     // The maximum assigned safepoint number
@@ -255,8 +258,11 @@ struct State {
     // The result of the local analysis
     std::map<BasicBlock *, BBState> BBStates;
 
-    // Refinement map. If all of the values are rooted (-1 means a globally rooted value),
+    // Refinement map. If all of the values are rooted (-1 means an externally rooted value),
     // the key is already rooted (but not the other way around).
+    // At the end of `LocalScan` this map has a few properties
+    // 1. Values are either -1 or dominates the key
+    // 2. Therefore this is a DAG
     std::map<int, SmallVector<int, 1>> Refinements;
 
     // GC preserves map. All safepoints dominated by the map key, but not any
@@ -284,7 +290,7 @@ struct State {
     // We don't bother doing liveness on Allocas that were not mem2reg'ed.
     // they just get directly sunk into the root array.
     std::vector<AllocaInst *> Allocas;
-    State() : MaxPtrNumber(-1), MaxSafepointNumber(-1) {}
+    State(Function &F) : F(&F), DT(nullptr), MaxPtrNumber(-1), MaxSafepointNumber(-1) {}
 };
 
 namespace llvm {
@@ -347,19 +353,22 @@ private:
         NoteOperandUses(S, BBS, UI, BBS.UpExposedUses);
     }
     State LocalScan(Function &F);
-    void ComputeLiveness(Function &F, State &S);
-    void ComputeLiveSets(Function &F, State &S);
+    void ComputeLiveness(State &S);
+    void ComputeLiveSets(State &S);
     void PushGCFrame(AllocaInst *gcframe, unsigned NRoots, Instruction *InsertAfter);
     void PopGCFrame(AllocaInst *gcframe, Instruction *InsertBefore);
     std::vector<int> ColorRoots(const State &S);
     void PlaceGCFrameStore(State &S, unsigned R, unsigned MinColorRoot, const std::vector<int> &Colors, Value *GCFrame, Instruction *InsertionPoint);
-    void PlaceGCFrameStores(Function &F, State &S, unsigned MinColorRoot, const std::vector<int> &Colors, Value *GCFrame);
-    void PlaceRootsAndUpdateCalls(Function &F, std::vector<int> &Colors, State &S, std::map<Value *, std::pair<int, int>>);
+    void PlaceGCFrameStores(State &S, unsigned MinColorRoot, const std::vector<int> &Colors, Value *GCFrame);
+    void PlaceRootsAndUpdateCalls(std::vector<int> &Colors, State &S, std::map<Value *, std::pair<int, int>>);
     bool DefineFunctions(Module &M);
     bool runOnFunction(Function &F) override;
     Instruction *get_pgcstack(Instruction *ptlsStates);
     bool CleanupIR(Function &F);
     void NoteUseChain(State &S, BBState &BBS, User *TheUser);
+    SmallVector<int, 1> GetPHIRefinements(PHINode *phi, State &S);
+    void FixUpRefinements(ArrayRef<int> PHINumbers, State &S);
+    void RefineLiveSet(BitVector &LS, State &S);
 };
 
 static unsigned getValueAddrSpace(Value *V) {
@@ -748,8 +757,143 @@ static bool LooksLikeFrameRef(Value *V) {
     return isa<Argument>(V);
 }
 
+SmallVector<int, 1> LateLowerGCFrame::GetPHIRefinements(PHINode *Phi, State &S)
+{
+    // The returned vector can violate the domination property of the Refinements map.
+    // However, we can't know for sure if this is valid here since incoming values
+    // that does not dominate the PHI node may be externally rooted (i.e. can be refined to -1)
+    // We only know that after scaning the whole function so we'll record the possibly invalid
+    // edges here and fix them up at the end of `LocalScan`. (See `FixUpRefinements` below).
+    auto nIncoming = Phi->getNumIncomingValues();
+    SmallVector<int, 1> RefinedPtr(nIncoming);
+    for (unsigned i = 0; i < nIncoming; ++i)
+        RefinedPtr[i] = Number(S, Phi->getIncomingValue(i));
+    return RefinedPtr;
+}
+
+void LateLowerGCFrame::FixUpRefinements(ArrayRef<int> PHINumbers, State &S)
+{
+    // Now we have all the possible refinement information, we can remove ones for the invalid
+
+    // * First find all values that must be externally rooted.
+    //   Values that might not be externally rooted must either have no refinement (the majority)
+    //   or have one of the value it's derived from (one of its refinements) be possibly
+    //   not externally rooted.
+    //
+    //   All other values can only possibly be externally rooted values,
+    //   which can include loops (of phi nodes).
+    //   We do this by first assuming all values to be externally rooted and then removing
+    //   values that are or can be derived from non-externally rooted values recursively.
+    BitVector extern_rooted(S.MaxPtrNumber + 1, true);
+    //   * First clear all values that are not derived from anything.
+    //     This only needs to be done once.
+    for (int i = 0; i <= S.MaxPtrNumber; i++) {
+        auto it = S.Refinements.find(i);
+        if (it == S.Refinements.end() || it->second.empty()) {
+            extern_rooted[i] = false;
+        }
+    }
+    //   * Then remove values reachable from those values recursively
+    bool changed;
+    do {
+        changed = false;
+        for (auto &kv: S.Refinements) {
+            int Num = kv.first;
+            // Already cleared.
+            if (!HasBitSet(extern_rooted, Num))
+                continue;
+            for (auto refine: kv.second) {
+                if (refine == -1)
+                    continue;
+                if (!HasBitSet(extern_rooted, refine)) {
+                    changed = true;
+                    extern_rooted[Num] = false;
+                    break;
+                }
+            }
+        }
+    } while (changed);
+    //   * Now the `extern_rooted` map is accurate, normalize all externally rooted values.
+    for (auto &kv: S.Refinements) {
+        int Num = kv.first;
+        if (HasBitSet(extern_rooted, Num)) {
+            // For externally rooted values, set their refinements simply to `{-1}`
+            kv.second.resize(1);
+            kv.second[0] = -1;
+            continue;
+        }
+        for (auto &refine: kv.second) {
+            // For other values,
+            // remove all externally rooted values from their refinements (replace with -1)
+            if (HasBitSet(extern_rooted, refine)) {
+                refine = -1;
+            }
+        }
+    }
+    // Scan all phi node refinements and remove all invalid ones.
+    // As a generalization to what we did to externally rooted values above,
+    // we can also relax non-dominating (invalid) refinements to the refinements of those values
+    // If all of those values dominate the phi node then the phi node can be refined to
+    // those values instead.
+    // While we recursively relax the refinement, we need to keep track of the the values we've
+    // visited in order to not scan them again.
+    BitVector visited(S.MaxPtrNumber + 1, false);
+    for (auto Num: PHINumbers) {
+        // Not sure if `Num` can be `-1`
+        if (Num == -1 || HasBitSet(extern_rooted, Num))
+            continue;
+        visited[Num] = true;
+        auto Phi = cast<PHINode>(S.ReversePtrNumbering[Num]);
+        auto &RefinedPtr = S.Refinements[Num];
+        int j = 0; // new length
+        for (unsigned i = 0; i < RefinedPtr.size(); i++) {
+            auto refine = RefinedPtr[i];
+            if (refine == -1 || visited[refine])
+                continue;
+            visited[refine] = true;
+            if (i != j)
+                RefinedPtr[j] = refine;
+            j++;
+            if (auto inst = dyn_cast<Instruction>(S.ReversePtrNumbering[refine])) {
+                if (!S.DT)
+                    S.DT = &getAnalysis<DominatorTreeWrapperPass>().getDomTree();
+                if (S.DT->dominates(inst, Phi))
+                    continue;
+                // Decrement `j` so we'll overwrite/igore it.
+                j--;
+                // Non-dominating refinement
+                auto it = S.Refinements.find(refine);
+                if (it != S.Refinements.end() && !it->second.empty()) {
+                    // Found a replacement, replace current element.
+                    auto &NewRefinedPtr = it->second;
+                    auto n = NewRefinedPtr.size();
+                    // First fill in the gap between `i` and `j`
+                    int k = 0;
+                    for (; k < n && i >= j + k; k++)
+                        RefinedPtr[i - k] = NewRefinedPtr[k];
+                    i = i - k;
+                    if (k < n)
+                        RefinedPtr.append(it->second.begin() + k, it->second.end());
+                    continue;
+                }
+                // Invalid
+                RefinedPtr = SmallVector<int, 1>{};
+                break;
+            }
+        }
+        if (!RefinedPtr.empty()) {
+            // `j == 0` here means that everything is externally rooted.
+            // This should have been handled by the first loop above.
+            assert(j != 0 && j <= RefinedPtr.size());
+            RefinedPtr.resize(j);
+        }
+        visited.reset();
+    }
+}
+
 State LateLowerGCFrame::LocalScan(Function &F) {
-    State S;
+    State S(F);
+    SmallVector<int, 16> PHINumbers;
     for (BasicBlock &BB : F) {
         BBState &BBS = S.BBStates[&BB];
         for (auto it = BB.rbegin(); it != BB.rend(); ++it) {
@@ -861,17 +1005,11 @@ State LateLowerGCFrame::LocalScan(Function &F) {
                         continue;
                     auto Num = LiftPhi(S, Phi);
                     auto lift = cast<PHINode>(S.ReversePtrNumbering[Num]);
-                    SmallVector<int, 1> RefinedPtr(0);
-                    // DISABLED DUE TO BUG IN THE ALGORITHM (#24098)
-                    //for (unsigned i = 0; i < nIncoming; ++i)
-                    //    RefinedPtr[i] = Number(S, lift->getIncomingValue(i));
-                    S.Refinements[Num] = std::move(RefinedPtr);
+                    S.Refinements[Num] = GetPHIRefinements(lift, S);
+                    PHINumbers.push_back(Num);
                 } else {
-                    SmallVector<int, 1> RefinedPtr(0);
-                    // DISABLED DUE TO BUG IN THE ALGORITHM (#24098)
-                    //for (unsigned i = 0; i < nIncoming; ++i)
-                    //    RefinedPtr[i] = Number(S, Phi->getIncomingValue(i));
-                    MaybeNoteDef(S, BBS, Phi, BBS.Safepoints, std::move(RefinedPtr));
+                    MaybeNoteDef(S, BBS, Phi, BBS.Safepoints, GetPHIRefinements(Phi, S));
+                    PHINumbers.push_back(Number(S, Phi));
                     for (unsigned i = 0; i < nIncoming; ++i) {
                         BBState &IncomingBBS = S.BBStates[Phi->getIncomingBlock(i)];
                         NoteUse(S, IncomingBBS, Phi->getIncomingValue(i), IncomingBBS.PhiOuts);
@@ -904,6 +1042,7 @@ State LateLowerGCFrame::LocalScan(Function &F) {
         BBS.UnrootedOut = BBS.DownExposedUnrooted;
         BBS.Done = true;
     }
+    FixUpRefinements(PHINumbers, S);
     return S;
 }
 
@@ -917,7 +1056,7 @@ State LateLowerGCFrame::LocalScan(Function &F) {
  * We'll perform textbook iterative dataflow to compute this. There are better
  * algorithms. If this starts becoming a problem, we should use one of them.
  */
-void LateLowerGCFrame::ComputeLiveness(Function &F, State &S) {
+void LateLowerGCFrame::ComputeLiveness(State &S) {
     bool Converged = false;
     /* Liveness is a reverse problem. Our problem is slightly more general,
      * because the Unrooted* variables are forward problems. Nevertheless,
@@ -925,7 +1064,7 @@ void LateLowerGCFrame::ComputeLiveness(Function &F, State &S) {
      * variables, in anticipation of the live ranges being larger than the
      * unrooted ranges (since those terminate at any safe point).
      */
-    ReversePostOrderTraversal<Function *> RPOT(&F);
+    ReversePostOrderTraversal<Function *> RPOT(S.F);
     while (!Converged) {
         bool AnyChanged = false;
         for (BasicBlock *BB : RPOT) {
@@ -964,7 +1103,7 @@ void LateLowerGCFrame::ComputeLiveness(Function &F, State &S) {
         }
         Converged = !AnyChanged;
     }
-    ComputeLiveSets(F, S);
+    ComputeLiveSets(S);
 }
 
 // For debugging
@@ -982,24 +1121,35 @@ JL_USED_FUNC static void dumpSafepointsForBBName(Function &F, State &S, const ch
     }
 }
 
-void LateLowerGCFrame::ComputeLiveSets(Function &F, State &S) {
-    DominatorTree *DT = nullptr;
-    // Iterate over all safe points. Add to live sets all those variables that
-    // are now live across their parent block.
-    for (auto it : S.SafepointNumbering) {
-        int idx = it.second;
-        Instruction *Safepoint = it.first;
-        BasicBlock *BB = Safepoint->getParent();
-        BBState &BBS = S.BBStates[BB];
-        BitVector LiveAcross = BBS.LiveIn;
-        LiveAcross &= BBS.LiveOut;
-        BitVector &LS = S.LiveSets[idx];
-        LS |= LiveAcross;
-        for (int Live : S.LiveIfLiveOut[idx]) {
-            if (HasBitSet(BBS.LiveOut, Live))
-                LS[Live] = 1;
+void LateLowerGCFrame::RefineLiveSet(BitVector &LS, State &S)
+{
+    BitVector FullLS(S.MaxPtrNumber + 1, false);
+    FullLS |= LS;
+    // First expand the live set according to the refinement map
+    // so that we can see all the values that are effectively live.
+    bool changed;
+    do {
+        changed = false;
+        for (auto &kv: S.Refinements) {
+            int Num = kv.first;
+            if (Num == -1 || HasBitSet(FullLS, Num) || kv.second.empty())
+                continue;
+            bool live = true;
+            for (auto &refine: kv.second) {
+                if (refine == -1 || HasBitSet(FullLS, refine))
+                    continue;
+                live = false;
+                break;
+            }
+            if (live) {
+                changed = true;
+                FullLS[Num] = 1;
+            }
         }
-        // Apply refinements
+    } while (changed);
+    // Now remove all values from the LiveSet that's kept alive by other objects
+    do {
+        changed = false;
         for (int Idx = LS.find_first(); Idx >= 0; Idx = LS.find_next(Idx)) {
             if (!S.Refinements.count(Idx))
                 continue;
@@ -1008,29 +1158,50 @@ void LateLowerGCFrame::ComputeLiveSets(Function &F, State &S) {
                 continue;
             bool rooted = true;
             for (auto RefPtr: RefinedPtr) {
-                if (RefPtr == -1 || HasBitSet(LS, RefPtr))
+                if (RefPtr == -1 || HasBitSet(FullLS, RefPtr))
                     continue;
                 rooted = false;
                 break;
             }
             if (rooted) {
+                changed = true;
                 LS[Idx] = 0;
             }
         }
+    } while (changed);
+}
+
+void LateLowerGCFrame::ComputeLiveSets(State &S) {
+    // Iterate over all safe points. Add to live sets all those variables that
+    // are now live across their parent block.
+    for (auto it : S.SafepointNumbering) {
+        int idx = it.second;
+        Instruction *Safepoint = it.first;
+        BasicBlock *BB = Safepoint->getParent();
+        BBState &BBS = S.BBStates[BB];
+        BitVector LiveAcross = BBS.LiveIn;
+        LiveAcross &= BBS.LiveOut;
+        BitVector &LS = S.LiveSets[idx];
+        LS |= LiveAcross;
+        for (int Live : S.LiveIfLiveOut[idx]) {
+            if (HasBitSet(BBS.LiveOut, Live))
+                LS[Live] = 1;
+        }
+        RefineLiveSet(LS, S);
         // If the function has GC preserves, figure out whether we need to
         // add in any extra live values.
         if (!S.GCPreserves.empty()) {
-            if (!DT) {
-                DT = &getAnalysis<DominatorTreeWrapperPass>().getDomTree();
+            if (!S.DT) {
+                S.DT = &getAnalysis<DominatorTreeWrapperPass>().getDomTree();
             }
             for (auto it2 : S.GCPreserves) {
-                if (!DT->dominates(it2.first, Safepoint))
+                if (!S.DT->dominates(it2.first, Safepoint))
                     continue;
                 bool OutsideRange = false;
                 for (const User *U : it2.first->users()) {
                     // If this is dominated by an end, we don't need to add
                     // the values to our live set.
-                    if (DT->dominates(cast<Instruction>(U), Safepoint)) {
+                    if (S.DT->dominates(cast<Instruction>(U), Safepoint)) {
                         OutsideRange = true;
                         break;
                     }
@@ -1430,10 +1601,10 @@ void LateLowerGCFrame::PlaceGCFrameStore(State &S, unsigned R, unsigned MinColor
     new StoreInst(Val, gep, InsertionPoint);
 }
 
-void LateLowerGCFrame::PlaceGCFrameStores(Function &F, State &S, unsigned MinColorRoot,
+void LateLowerGCFrame::PlaceGCFrameStores(State &S, unsigned MinColorRoot,
                                           const std::vector<int> &Colors, Value *GCFrame)
 {
-    for (auto &BB : F) {
+    for (auto &BB : *S.F) {
         const BBState &BBS = S.BBStates[&BB];
         if (!BBS.HasSafepoint) {
             continue;
@@ -1455,7 +1626,8 @@ void LateLowerGCFrame::PlaceGCFrameStores(Function &F, State &S, unsigned MinCol
     }
 }
 
-void LateLowerGCFrame::PlaceRootsAndUpdateCalls(Function &F, std::vector<int> &Colors, State &S, std::map<Value *, std::pair<int, int>>) {
+void LateLowerGCFrame::PlaceRootsAndUpdateCalls(std::vector<int> &Colors, State &S, std::map<Value *, std::pair<int, int>>) {
+    auto F = S.F;
     int MaxColor = -1;
     for (auto C : Colors)
         if (C > MaxColor)
@@ -1469,18 +1641,18 @@ void LateLowerGCFrame::PlaceRootsAndUpdateCalls(Function &F, std::vector<int> &C
            0,
 #endif
         ConstantInt::get(T_int32, NRoots+2), "gcframe");
-        gcframe->insertBefore(&*F.getEntryBlock().begin());
+        gcframe->insertBefore(&*F->getEntryBlock().begin());
         // Zero out gcframe
-        BitCastInst *tempSlot_i8 = new BitCastInst(gcframe, Type::getInt8PtrTy(F.getContext()), "");
+        BitCastInst *tempSlot_i8 = new BitCastInst(gcframe, Type::getInt8PtrTy(F->getContext()), "");
         tempSlot_i8->insertAfter(gcframe);
         Type *argsT[2] = {tempSlot_i8->getType(), T_int32};
-        Function *memset = Intrinsic::getDeclaration(F.getParent(), Intrinsic::memset, makeArrayRef(argsT));
+        Function *memset = Intrinsic::getDeclaration(F->getParent(), Intrinsic::memset, makeArrayRef(argsT));
         Value *args[5] = {
             tempSlot_i8, // dest
-            ConstantInt::get(Type::getInt8Ty(F.getContext()), 0), // val
+            ConstantInt::get(Type::getInt8Ty(F->getContext()), 0), // val
             ConstantInt::get(T_int32, sizeof(jl_value_t*)*(NRoots+2)), // len
             ConstantInt::get(T_int32, 0), // align
-            ConstantInt::get(Type::getInt1Ty(F.getContext()), 0)}; // volatile
+            ConstantInt::get(Type::getInt1Ty(F->getContext()), 0)}; // volatile
         CallInst *zeroing = CallInst::Create(memset, makeArrayRef(args));
         zeroing->setMetadata(llvm::LLVMContext::MD_tbaa, tbaa_gcframe);
         zeroing->insertAfter(tempSlot_i8);
@@ -1512,9 +1684,9 @@ void LateLowerGCFrame::PlaceRootsAndUpdateCalls(Function &F, std::vector<int> &C
         }
         unsigned MinColorRoot = AllocaSlot;
         // Insert GC frame stores
-        PlaceGCFrameStores(F, S, MinColorRoot, Colors, gcframe);
+        PlaceGCFrameStores(S, MinColorRoot, Colors, gcframe);
         // Insert GCFrame pops
-        for(Function::iterator I = F.begin(), E = F.end(); I != E; ++I) {
+        for(Function::iterator I = F->begin(), E = F->end(); I != E; ++I) {
             if (isa<ReturnInst>(I->getTerminator())) {
                 PopGCFrame(gcframe, I->getTerminator());
             }
@@ -1605,10 +1777,10 @@ bool LateLowerGCFrame::runOnFunction(Function &F) {
     if (!ptlsStates)
         return CleanupIR(F);
     State S = LocalScan(F);
-    ComputeLiveness(F, S);
+    ComputeLiveness(S);
     std::vector<int> Colors = ColorRoots(S);
     std::map<Value *, std::pair<int, int>> CallFrames; // = OptimizeCallFrames(S, Ordering);
-    PlaceRootsAndUpdateCalls(F, Colors, S, CallFrames);
+    PlaceRootsAndUpdateCalls(Colors, S, CallFrames);
     CleanupIR(F);
     return true;
 }
diff --git a/test/codegen.jl b/test/codegen.jl
index d59ce83e01..a49a890c4c 100644
--- a/test/codegen.jl
+++ b/test/codegen.jl
@@ -284,15 +284,25 @@ function g22421_2(x, y, b)
     return f22421_3(x, y, b ? x : y, 1)
 end
 
+struct A24108
+    x::Vector{Int}
+end
+struct B24108
+    x::A24108
+end
+@noinline f24108(x) = length(x)
+# Test no gcframe is allocated for `x.x.x` even though `x.x` isn't live at the call site
+g24108(x::B24108) = f24108(x.x.x)
+
 @test g22421_1(Ref(1), Ref(2), true) === 7
 @test g22421_1(Ref(3), Ref(4), false) === 16
 @test g22421_2(Ref(5), Ref(6), true) === 17
 @test g22421_2(Ref(7), Ref(8), false) === 24
 
 if opt_level > 0
-    # Disable temporarily. Don't use `@test_broken` since these won't reliably fail either
-    # @test !contains(get_llvm(g22421_1, Tuple{Base.RefValue{Int},Base.RefValue{Int},Bool}),
-    #                 "%gcframe")
-    # @test !contains(get_llvm(g22421_2, Tuple{Base.RefValue{Int},Base.RefValue{Int},Bool}),
-    #                 "%gcframe")
+    @test !contains(get_llvm(g22421_1, Tuple{Base.RefValue{Int},Base.RefValue{Int},Bool}),
+                    "%gcframe")
+    @test !contains(get_llvm(g22421_2, Tuple{Base.RefValue{Int},Base.RefValue{Int},Bool}),
+                    "%gcframe")
+    @test !contains(get_llvm(g24108, Tuple{B24108}), "%gcframe")
 end
diff --git a/test/llvmpasses/gcroots.ll b/test/llvmpasses/gcroots.ll
index 5d32800740..a8cdca128c 100644
--- a/test/llvmpasses/gcroots.ll
+++ b/test/llvmpasses/gcroots.ll
@@ -289,27 +289,6 @@ top:
     ret %jl_value_t addrspace(10)* %v1
 }
 
-define void @refine_select_phi(%jl_value_t addrspace(10)* %x, %jl_value_t addrspace(10)* %y, i1 %b) {
-; CHECK-LABEL: @refine_select_phi
-; CHECK-NOT: %gcframe
-top:
-  %ptls = call %jl_value_t*** @julia.ptls_states()
-  %s = select i1 %b, %jl_value_t addrspace(10)* %x, %jl_value_t addrspace(10)* %y
-  br i1 %b, label %L1, label %L2
-
-L1:
-  br label %L3
-
-L2:
-  br label %L3
-
-L3:
-  %p = phi %jl_value_t addrspace(10)* [ %x, %L1 ], [ %y, %L2 ]
-  call void @one_arg_boxed(%jl_value_t addrspace(10)* %s)
-  call void @one_arg_boxed(%jl_value_t addrspace(10)* %p)
-  ret void
-}
-
 !0 = !{!"jtbaa"}
 !1 = !{!"jtbaa_const", !0, i64 0}
 !2 = !{!1, !1, i64 0, i64 1}
diff --git a/test/llvmpasses/refinements.ll b/test/llvmpasses/refinements.ll
index fe60cdc2dc..64b3011d85 100644
--- a/test/llvmpasses/refinements.ll
+++ b/test/llvmpasses/refinements.ll
@@ -76,6 +76,116 @@ define void @issue22770() {
     ret void
 }
 
+define void @refine_select_phi(%jl_value_t addrspace(10)* %x, %jl_value_t addrspace(10)* %y, i1 %b) {
+; CHECK-LABEL: @refine_select_phi
+; CHECK-NOT: %gcframe
+top:
+  %ptls = call %jl_value_t*** @julia.ptls_states()
+  %s = select i1 %b, %jl_value_t addrspace(10)* %x, %jl_value_t addrspace(10)* %y
+  br i1 %b, label %L1, label %L2
+
+L1:
+  br label %L3
+
+L2:
+  br label %L3
+
+L3:
+  %p = phi %jl_value_t addrspace(10)* [ %x, %L1 ], [ %y, %L2 ]
+  call void @one_arg_boxed(%jl_value_t addrspace(10)* %s)
+  call void @one_arg_boxed(%jl_value_t addrspace(10)* %p)
+  ret void
+}
+
+define void @dont_refine_loop(%jl_value_t addrspace(10)* %x) {
+; CHECK-LABEL: @dont_refine_loop
+; CHECK: %gcframe = alloca %jl_value_t addrspace(10)*, i32 4
+top:
+  %ptls = call %jl_value_t*** @julia.ptls_states()
+  br label %L1
+
+L1:
+  %continue = phi i1 [ true, %top ], [ false, %L1 ]
+  %p = phi %jl_value_t addrspace(10)* [ %x, %top ], [ %v, %L1 ]
+  %v = call %jl_value_t addrspace(10)* @allocate_some_value()
+  call void @one_arg_boxed(%jl_value_t addrspace(10)* %v)
+  call void @one_arg_boxed(%jl_value_t addrspace(10)* %p)
+  br i1 %continue, label %L1, label %L2
+
+L2:
+  ret void
+}
+
+@gv1 = external global %jl_value_t*
+
+define void @refine_loop_const(%jl_value_t addrspace(10)* %x) {
+; CHECK-LABEL: @refine_loop_const
+; CHECK-NOT: %gcframe
+top:
+  %ptls = call %jl_value_t*** @julia.ptls_states()
+  br label %L1
+
+L1:
+  %continue = phi i1 [ true, %top ], [ false, %L1 ]
+  %p = phi %jl_value_t addrspace(10)* [ %x, %top ], [ %v, %L1 ]
+  %v0 = load %jl_value_t*, %jl_value_t** @gv1, !tbaa !4
+  %v = addrspacecast %jl_value_t* %v0 to %jl_value_t addrspace(10)*
+  call void @one_arg_boxed(%jl_value_t addrspace(10)* %v)
+  call void @one_arg_boxed(%jl_value_t addrspace(10)* %p)
+  br i1 %continue, label %L1, label %L2
+
+L2:
+  ret void
+}
+
+define void @refine_loop_indirect(%jl_value_t addrspace(10)* %x) {
+; CHECK-LABEL: @refine_loop_indirect
+; CHECK: %gcframe = alloca %jl_value_t addrspace(10)*, i32 3
+top:
+  %ptls = call %jl_value_t*** @julia.ptls_states()
+  %a = call %jl_value_t addrspace(10)* @allocate_some_value()
+  br label %L1
+
+L1:
+  %continue = phi i1 [ true, %top ], [ false, %L1 ]
+; `%v` is not a valid refinement incoming value of the phi node `%p`,
+; however, `%v` can be refined to `%a` and `%a` is a valid refinement
+; of the phi node. Therefore, we need only one gc slot for `%a`.
+  %p = phi %jl_value_t addrspace(10)* [ %x, %top ], [ %v, %L1 ]
+  %ca = bitcast %jl_value_t addrspace(10)* %a to %jl_value_t addrspace(10)* addrspace(10)*
+  %v = load %jl_value_t addrspace(10)*, %jl_value_t addrspace(10)* addrspace(10)* %ca, !tbaa !1
+  call void @one_arg_boxed(%jl_value_t addrspace(10)* %v)
+  call void @one_arg_boxed(%jl_value_t addrspace(10)* %p)
+  br i1 %continue, label %L1, label %L2
+
+L2:
+  ret void
+}
+
+define void @refine_loop_indirect2(%jl_value_t addrspace(10)* %x) {
+; CHECK-LABEL: @refine_loop_indirect2
+; CHECK: %gcframe = alloca %jl_value_t addrspace(10)*, i32 3
+top:
+  %ptls = call %jl_value_t*** @julia.ptls_states()
+  %a = call %jl_value_t addrspace(10)* @allocate_some_value()
+  br label %L1
+
+L1:
+  %continue = phi i1 [ true, %top ], [ false, %L1 ]
+; `%p` has circular dependency but it can only be derived from `%a` which dominate `%p`.
+  %p = phi %jl_value_t addrspace(10)* [ %a, %top ], [ %v, %L1 ]
+  %ca = bitcast %jl_value_t addrspace(10)* %p to %jl_value_t addrspace(10)* addrspace(10)*
+  %v = load %jl_value_t addrspace(10)*, %jl_value_t addrspace(10)* addrspace(10)* %ca, !tbaa !1
+  call void @one_arg_boxed(%jl_value_t addrspace(10)* %v)
+  call void @one_arg_boxed(%jl_value_t addrspace(10)* %p)
+  br i1 %continue, label %L1, label %L2
+
+L2:
+  ret void
+}
+
 !0 = !{!"jtbaa"}
 !1 = !{!2, !2, i64 0}
 !2 = !{!"jtbaa_immut", !0, i64 0}
+!3 = !{!"jtbaa_const", !0, i64 0}
+!4 = !{!3, !3, i64 0, i64 1}
-- 
2.14.2

