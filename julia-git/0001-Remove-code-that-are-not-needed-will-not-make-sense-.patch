From 460ee0ce14586369866720cffb0a78530c1ef1b0 Mon Sep 17 00:00:00 2001
From: Yichao Yu <yyc1992@gmail.com>
Date: Sat, 13 May 2017 16:25:35 -0400
Subject: [PATCH 1/9] Remove code that are not needed/will not make sense with
 function multi-versioning and improved cpu selection/detection.

* Remove cpuid specific binary

    To be replaced by function multi-versioning

* Remove old CPU target handling in sysimg

    The feature check is not complete since X86 features bits
    are also in many other CPUID results, including ones that
    we are actually interested in like AVX2.

* Add invalid CPU name and help handling in codegen initialization.

    Update `--cpu-target` test
    since target mismatch will not raise an error anymore.
    CPU names unknown to LLVM would.
---
 Make.inc             |  5 -----
 Makefile             | 15 ++-------------
 base/pkg/pkg.jl      |  2 --
 src/Makefile         |  4 ----
 src/codegen.cpp      | 20 ++++++++++++++++++++
 src/jitlayers.cpp    | 29 -----------------------------
 src/jloptions.c      |  9 +--------
 src/julia.h          |  2 --
 src/julia_internal.h |  4 ----
 src/staticdata.c     | 38 +++++++-------------------------------
 src/sys.c            | 25 +------------------------
 test/cmdlineargs.jl  | 11 +++--------
 ui/repl.c            |  7 -------
 13 files changed, 34 insertions(+), 137 deletions(-)

diff --git a/Make.inc b/Make.inc
index e776816699..7684b10945 100644
--- a/Make.inc
+++ b/Make.inc
@@ -81,11 +81,6 @@ HAVE_SSP := 0
 WITH_GC_VERIFY := 0
 WITH_GC_DEBUG_ENV := 0
 
-# When set, give julia binaries CPUID specific names. This is useful in cluster environments
-# with heterogeneous architectures. N.B.: will not be automatically rebuilt for all
-# architectures if julia is updated.
-CPUID_SPECIFIC_BINARIES ?= 0
-
 # Prevent picking up $ARCH from the environment variables
 ARCH:=
 
diff --git a/Makefile b/Makefile
index c100eb8072..cbdf4c9d7b 100644
--- a/Makefile
+++ b/Makefile
@@ -104,17 +104,11 @@ julia-ui-release julia-ui-debug : julia-ui-% : julia-src-%
 julia-inference : julia-base julia-ui-$(JULIA_BUILD_MODE) $(build_prefix)/.examples
 	@$(MAKE) $(QUIET_MAKE) -C $(BUILDROOT) $(build_private_libdir)/inference.ji JULIA_BUILD_MODE=$(JULIA_BUILD_MODE)
 
-ifneq ($(CPUID_SPECIFIC_BINARIES), 0)
-CPUID_TAG = _$(call exec,$(JULIA_EXECUTABLE) --cpuid)
-else
-CPUID_TAG =
-endif
-
 julia-sysimg-release : julia-inference julia-ui-release
-	@$(MAKE) $(QUIET_MAKE) -C $(BUILDROOT) $(build_private_libdir)/sys$(CPUID_TAG).$(SHLIB_EXT) JULIA_BUILD_MODE=release
+	@$(MAKE) $(QUIET_MAKE) -C $(BUILDROOT) $(build_private_libdir)/sys.$(SHLIB_EXT) JULIA_BUILD_MODE=release
 
 julia-sysimg-debug : julia-inference julia-ui-debug
-	@$(MAKE) $(QUIET_MAKE) -C $(BUILDROOT) $(build_private_libdir)/sys-debug$(CPUID_TAG).$(SHLIB_EXT) JULIA_BUILD_MODE=debug
+	@$(MAKE) $(QUIET_MAKE) -C $(BUILDROOT) $(build_private_libdir)/sys-debug.$(SHLIB_EXT) JULIA_BUILD_MODE=debug
 
 julia-debug julia-release : julia-% : julia-ui-% julia-sysimg-% julia-symlink julia-libccalltest
 
@@ -231,13 +225,8 @@ $$(build_private_libdir)/sys$1.o: $$(build_private_libdir)/inference.ji $$(JULIA
 	fi )
 .SECONDARY: $(build_private_libdir)/sys$1.o
 endef
-ifneq ($(CPUID_SPECIFIC_BINARIES),0)
-$(eval $(call sysimg_builder,_%,-O3,$(JULIA_EXECUTABLE_release)))
-$(eval $(call sysimg_builder,-debug_%,-O0,$(JULIA_EXECUTABLE_debug)))
-else
 $(eval $(call sysimg_builder,,-O3,$(JULIA_EXECUTABLE_release)))
 $(eval $(call sysimg_builder,-debug,-O0,$(JULIA_EXECUTABLE_debug)))
-endif
 
 $(build_depsbindir)/stringreplace: $(JULIAHOME)/contrib/stringreplace.c | $(build_depsbindir)
 	@$(call PRINT_CC, $(HOSTCC) -o $(build_depsbindir)/stringreplace $(JULIAHOME)/contrib/stringreplace.c)
diff --git a/base/pkg/pkg.jl b/base/pkg/pkg.jl
index cb9df70635..69634126d3 100644
--- a/base/pkg/pkg.jl
+++ b/base/pkg/pkg.jl
@@ -86,8 +86,6 @@ init(meta::AbstractString=DEFAULT_META, branch::AbstractString=META_BRANCH) = Di
 
 function __init__()
     vers = "v$(VERSION.major).$(VERSION.minor)"
-    vers = ccall(:jl_uses_cpuid_tag, Cint, ()) == 0 ? vers :
-        joinpath(vers,hex(ccall(:jl_cpuid_tag, UInt64, ()), 2*sizeof(UInt64)))
     unshift!(Base.LOAD_CACHE_PATH, abspath(Dir._pkgroot(), "lib", vers))
 end
 
diff --git a/src/Makefile b/src/Makefile
index d3ff989009..daefd06365 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -109,10 +109,6 @@ SHIPFLAGS += $(FLAGS)
 SHIPFLAGS += "-DJL_SYSTEM_IMAGE_PATH=\"$(build_private_libdir_rel)/sys.$(SHLIB_EXT)\""
 DEBUGFLAGS += "-DJL_SYSTEM_IMAGE_PATH=\"$(build_private_libdir_rel)/sys-debug.$(SHLIB_EXT)\""
 
-ifneq ($(CPUID_SPECIFIC_BINARIES), 0)
-override CPPFLAGS += "-DCPUID_SPECIFIC_BINARIES=1"
-endif
-
 FLISP_EXECUTABLE_debug := $(BUILDDIR)/flisp/flisp-debug
 FLISP_EXECUTABLE_release := $(BUILDDIR)/flisp/flisp
 ifeq ($(OS),WINNT)
diff --git a/src/codegen.cpp b/src/codegen.cpp
index e1a3f99e14..2960cfc80b 100644
--- a/src/codegen.cpp
+++ b/src/codegen.cpp
@@ -6840,8 +6840,28 @@ extern "C" void *jl_init_llvm(void)
 #if defined(FORCE_ELF)
     TheTriple.setObjectFormat(Triple::ELF);
 #endif
+    bool help = false;
+    if (jl_options.cpu_target && strcmp(jl_options.cpu_target, "help") == 0) {
+        help = true;
+        jl_options.cpu_target = "native";
+    }
     std::string TheCPU;
     SmallVector<std::string, 10> targetFeatures = getTargetFeatures(TheCPU);
+    {
+        std::string errorstr;
+        const Target *target = TargetRegistry::lookupTarget("", TheTriple, errorstr);
+        assert(target);
+        std::unique_ptr<MCSubtargetInfo> MSTI(
+            target->createMCSubtargetInfo(TheTriple.str(), "", ""));
+        if (!MSTI->isCPUStringValid(TheCPU))
+            jl_errorf("Invalid CPU name %s.", TheCPU.c_str());
+        if (help) {
+            // This is the only way I can find to print the help message once.
+            // It'll be nice if we can iterate through the features and print our own help
+            // message...
+            MSTI->setDefaultFeatures("help", "");
+        }
+    }
     jl_TargetMachine = eb.selectTarget(
             TheTriple,
             "",
diff --git a/src/jitlayers.cpp b/src/jitlayers.cpp
index 73a2701414..754bc5db76 100644
--- a/src/jitlayers.cpp
+++ b/src/jitlayers.cpp
@@ -1017,12 +1017,6 @@ void jl_add_to_shadow(Module *m)
     jl_merge_module(shadow_output, std::move(clone));
 }
 
-#ifdef HAVE_CPUID
-extern "C" {
-    extern void jl_cpuid(int32_t CPUInfo[4], int32_t InfoType);
-}
-#endif
-
 static void emit_offset_table(Module *mod, const std::vector<GlobalValue*> &vars, StringRef name)
 {
     assert(!vars.empty());
@@ -1067,14 +1061,6 @@ static void jl_gen_llvm_globaldata(Module *mod, const char *sysimg_data, size_t
                                  "jl_tls_offset_idx"));
 #endif
 
-    Constant *feature_string = ConstantDataArray::getString(jl_LLVMContext, jl_options.cpu_target);
-    addComdat(new GlobalVariable(*mod,
-                                 feature_string->getType(),
-                                 true,
-                                 GlobalVariable::ExternalLinkage,
-                                 feature_string,
-                                 "jl_sysimg_cpu_target"));
-
     // reflect the address of the jl_RTLD_DEFAULT_handle variable
     // back to the caller, so that we can check for consistency issues
     GlobalValue *jlRTLD_DEFAULT_var = mod->getNamedValue("jl_RTLD_DEFAULT_handle");
@@ -1085,21 +1071,6 @@ static void jl_gen_llvm_globaldata(Module *mod, const char *sysimg_data, size_t
                                  jlRTLD_DEFAULT_var,
                                  "jl_RTLD_DEFAULT_handle_pointer"));
 
-#ifdef HAVE_CPUID
-    // For native also store the cpuid
-    if (strcmp(jl_options.cpu_target,"native") == 0) {
-        uint32_t info[4];
-
-        jl_cpuid((int32_t*)info, 1);
-        addComdat(new GlobalVariable(*mod,
-                                     T_uint64,
-                                     true,
-                                     GlobalVariable::ExternalLinkage,
-                                     ConstantInt::get(T_uint64,((uint64_t)info[2])|(((uint64_t)info[3])<<32)),
-                                     "jl_sysimg_cpu_cpuid"));
-    }
-#endif
-
     if (sysimg_data) {
         Constant *data = ConstantDataArray::get(jl_LLVMContext,
             ArrayRef<uint8_t>((const unsigned char*)sysimg_data, sysimg_len));
diff --git a/src/jloptions.c b/src/jloptions.c
index 7bd9729eaa..8c95a7f136 100644
--- a/src/jloptions.c
+++ b/src/jloptions.c
@@ -20,16 +20,9 @@ char *shlib_ext = ".dylib";
 char *shlib_ext = ".so";
 #endif
 
-static char system_image_path[256] = "\0" JL_SYSTEM_IMAGE_PATH;
+static const char system_image_path[256] = "\0" JL_SYSTEM_IMAGE_PATH;
 JL_DLLEXPORT const char *jl_get_default_sysimg_path(void)
 {
-#ifdef CPUID_SPECIFIC_BINARIES
-    char *path = &system_image_path[1];
-    size_t existing_length = strlen(path) - strlen(shlib_ext);
-    path += existing_length;
-    snprintf(path, sizeof(system_image_path) - existing_length,
-        "_%" PRIx64 "%s", jl_cpuid_tag(), shlib_ext);
-#endif
     return &system_image_path[1];
 }
 
diff --git a/src/julia.h b/src/julia.h
index 30e2c26548..95c091affb 100644
--- a/src/julia.h
+++ b/src/julia.h
@@ -1280,8 +1280,6 @@ JL_DLLEXPORT long jl_getallocationgranularity(void);
 JL_DLLEXPORT int jl_is_debugbuild(void);
 JL_DLLEXPORT jl_sym_t *jl_get_UNAME(void);
 JL_DLLEXPORT jl_sym_t *jl_get_ARCH(void);
-JL_DLLEXPORT uint64_t jl_cpuid_tag(void);
-JL_DLLEXPORT int jl_uses_cpuid_tag(void);
 
 // environment entries
 JL_DLLEXPORT jl_value_t *jl_environ(int i);
diff --git a/src/julia_internal.h b/src/julia_internal.h
index 4a587616da..8d1a44c658 100644
--- a/src/julia_internal.h
+++ b/src/julia_internal.h
@@ -734,10 +734,6 @@ void *jl_dlopen_soname(const char *pfx, size_t n, unsigned flags);
 // libuv wrappers:
 JL_DLLEXPORT int jl_fs_rename(const char *src_path, const char *dst_path);
 
-#if defined(_CPU_X86_) || defined(_CPU_X86_64_)
-#define HAVE_CPUID
-#endif
-
 #ifdef SEGV_EXCEPTION
 extern JL_DLLEXPORT jl_value_t *jl_segv_exception;
 #endif
diff --git a/src/staticdata.c b/src/staticdata.c
index a5d8146fca..2a2af6b300 100644
--- a/src/staticdata.c
+++ b/src/staticdata.c
@@ -129,10 +129,6 @@ static uint32_t read_uint32(ios_t *s)
 
 // --- Static Compile ---
 
-#ifdef HAVE_CPUID
-extern void jl_cpuid(int32_t CPUInfo[4], int32_t InfoType);
-#endif
-
 extern int globalUnique;
 static void *jl_sysimg_handle = NULL;
 static uint64_t sysimage_base = 0;
@@ -158,9 +154,6 @@ JL_DLLEXPORT int jl_running_on_valgrind(void)
 
 static void jl_load_sysimg_so(void)
 {
-#ifndef _OS_WINDOWS_
-    Dl_info dlinfo;
-#endif
     int imaging_mode = jl_generating_output() && !jl_options.incremental;
     // in --build mode only use sysimg data, not precompiled native code
     if (!imaging_mode && jl_options.use_sysimage_native_code==JL_OPTIONS_USE_SYSIMAGE_NATIVE_CODE_YES) {
@@ -181,31 +174,11 @@ static void jl_load_sysimg_so(void)
         *sysimg_gvars(sysimg_gvars_base, tls_offset_idx - 1) =
             (uintptr_t)(jl_tls_offset == -1 ? 0 : jl_tls_offset);
 #endif
-        const char *cpu_target = (const char*)jl_dlsym(jl_sysimg_handle, "jl_sysimg_cpu_target");
-        if (strcmp(cpu_target,jl_options.cpu_target) != 0)
-            jl_error("Julia and the system image were compiled for different architectures.\n"
-                     "Please delete or regenerate sys.{so,dll,dylib}.");
-#ifdef HAVE_CPUID
-        uint32_t info[4];
-        jl_cpuid((int32_t*)info, 1);
-        if (strcmp(cpu_target, "native") == 0) {
-            if (!RUNNING_ON_VALGRIND) {
-                uint64_t saved_cpuid = *(uint64_t*)jl_dlsym(jl_sysimg_handle, "jl_sysimg_cpu_cpuid");
-                if (saved_cpuid != (((uint64_t)info[2])|(((uint64_t)info[3])<<32)))
-                    jl_error("Target architecture mismatch. Please delete or regenerate sys.{so,dll,dylib}.");
-            }
-        }
-        else if (strcmp(cpu_target,"core2") == 0) {
-            int HasSSSE3 = (info[2] & 1<<9);
-            if (!HasSSSE3)
-                jl_error("The current host does not support SSSE3, but the system image was compiled for Core2.\n"
-                         "Please delete or regenerate sys.{so,dll,dylib}.");
-        }
-#endif
 
 #ifdef _OS_WINDOWS_
         sysimage_base = (intptr_t)jl_sysimg_handle;
 #else
+        Dl_info dlinfo;
         if (dladdr((void*)sysimg_gvars_base, &dlinfo) != 0) {
             sysimage_base = (intptr_t)dlinfo.dli_fbase;
         }
@@ -1360,13 +1333,16 @@ JL_DLLEXPORT void jl_preload_sysimg_so(const char *fname)
 // Allow passing in a module handle directly, rather than a path
 JL_DLLEXPORT void jl_set_sysimg_so(void *handle)
 {
-    // set cpu target if unspecified by user and available from sysimg
-    // otherwise default to native.
     void* *jl_RTLD_DEFAULT_handle_pointer = (void**)jl_dlsym_e(handle, "jl_RTLD_DEFAULT_handle_pointer");
     if (!jl_RTLD_DEFAULT_handle_pointer || (void*)&jl_RTLD_DEFAULT_handle != *jl_RTLD_DEFAULT_handle_pointer)
         jl_error("System image file failed consistency check: maybe opened the wrong version?");
+    // TODO make sure the sysimg and the JIT agrees on the ABI.
+    // This shouldn't be a problem for any required C types on any platforms we support
+    // but could be a problem from optional types. In particular, we need to make sure
+    // the two agrees on the usable register sizes so that functions that take
+    // a vector as input can use consistent calling convention.
     if (jl_options.cpu_target == NULL)
-        jl_options.cpu_target = (const char *)jl_dlsym(handle, "jl_sysimg_cpu_target");
+        jl_options.cpu_target = "native";
     jl_sysimg_handle = handle;
 }
 
diff --git a/src/sys.c b/src/sys.c
index 128664fc45..40f0a549ad 100644
--- a/src/sys.c
+++ b/src/sys.c
@@ -455,7 +455,7 @@ JL_DLLEXPORT JL_STREAM *jl_stderr_stream(void) { return JL_STDERR; }
 
 // CPUID
 
-#ifdef HAVE_CPUID
+#if defined(_CPU_X86_) || defined(_CPU_X86_64_)
 JL_DLLEXPORT void jl_cpuid(int32_t CPUInfo[4], int32_t InfoType)
 {
 #if defined _MSC_VER
@@ -478,31 +478,8 @@ JL_DLLEXPORT void jl_cpuid(int32_t CPUInfo[4], int32_t InfoType)
     );
 #endif
 }
-JL_DLLEXPORT uint64_t jl_cpuid_tag(void)
-{
-    uint32_t info[4];
-    jl_cpuid((int32_t *)info, 1);
-    return (((uint64_t)info[2]) | (((uint64_t)info[3]) << 32));
-}
-#elif defined(CPUID_SPECIFIC_BINARIES)
-#error "CPUID not available on this CPU. Turn off CPUID_SPECIFIC_BINARIES"
-#else
-// For architectures that don't have CPUID
-JL_DLLEXPORT uint64_t jl_cpuid_tag(void)
-{
-    return 0;
-}
 #endif
 
-JL_DLLEXPORT int jl_uses_cpuid_tag(void)
-{
-#ifdef CPUID_SPECIFIC_BINARIES
-    return 1;
-#else
-    return 0;
-#endif
-}
-
 // -- set/clear the FZ/DAZ flags on x86 & x86-64 --
 #ifdef __SSE__
 
diff --git a/test/cmdlineargs.jl b/test/cmdlineargs.jl
index 8220001ca1..12fcfbb03a 100644
--- a/test/cmdlineargs.jl
+++ b/test/cmdlineargs.jl
@@ -95,14 +95,9 @@ let exename = `$(Base.julia_cmd()) --sysimage-native-code=yes --startup-file=no`
     @test !success(`$exename -L`)
     @test !success(`$exename --load`)
 
-    # --cpu-target
-    # NOTE: this test only holds true if image_file is a shared library.
-    if Libdl.dlopen_e(unsafe_string(Base.JLOptions().image_file)) != C_NULL
-        @test !success(`$exename -C invalidtarget --sysimage-native-code=yes`)
-        @test !success(`$exename --cpu-target=invalidtarget --sysimage-native-code=yes`)
-    else
-        warn("--cpu-target test not runnable")
-    end
+    # --cpu-target (requires LLVM enabled)
+    @test !success(`$exename -C invalidtarget`)
+    @test !success(`$exename --cpu-target=invalidtarget`)
 
     # --procs
     @test readchomp(`$exename -q -p 2 -e "println(nworkers())"`) == "2"
diff --git a/ui/repl.c b/ui/repl.c
index 357f612a29..887ea69fa0 100644
--- a/ui/repl.c
+++ b/ui/repl.c
@@ -165,8 +165,6 @@ static NOINLINE int true_main(int argc, char *argv[])
     return 0;
 }
 
-extern JL_DLLEXPORT uint64_t jl_cpuid_tag();
-
 #ifndef _OS_WINDOWS_
 int main(int argc, char *argv[])
 {
@@ -231,11 +229,6 @@ int wmain(int argc, wchar_t *argv[], wchar_t *envp[])
         argv[i] = (wchar_t*)arg;
     }
 #endif
-    if (argc >= 2 && strcmp((char *)argv[1], "--cpuid") == 0) {
-        /* Used by the build system to name CPUID-specific binaries */
-        printf("%" PRIx64, jl_cpuid_tag());
-        return 0;
-    }
     libsupport_init();
     int lisp_prompt = (argc >= 2 && strcmp((char*)argv[1],"--lisp") == 0);
     if (lisp_prompt) {
-- 
2.14.2

