From 9f5a54ea786267a61d107b267bb57a056b9055b5 Mon Sep 17 00:00:00 2001
From: Yichao Yu <yyc1992@gmail.com>
Date: Thu, 20 Apr 2017 17:53:22 -0400
Subject: [PATCH 2/3] Make sure the codegen lock is acquired when calling LLVM
 in cfunction.

---
 src/codegen.cpp | 11 ++++++++---
 test/threads.jl | 14 ++++++++++++++
 2 files changed, 22 insertions(+), 3 deletions(-)

diff --git a/src/codegen.cpp b/src/codegen.cpp
index a42f4923ff..5de00ef196 100644
--- a/src/codegen.cpp
+++ b/src/codegen.cpp
@@ -1544,9 +1544,12 @@ void *jl_function_ptr(jl_function_t *f, jl_value_t *rt, jl_value_t *argt)
         // TODO: maybe deprecation warning, better checking
         argt = (jl_value_t*)jl_apply_tuple_type_v((jl_value_t**)jl_data_ptr(argt), jl_nfields(argt));
     }
+    JL_LOCK(&codegen_lock);
     Function *llvmf = jl_cfunction_object(f, rt, (jl_tupletype_t*)argt);
     JL_GC_POP();
-    return (void*)getAddressForFunction(llvmf);
+    void *ptr = (void*)getAddressForFunction(llvmf);
+    JL_UNLOCK(&codegen_lock);
+    return ptr;
 }
 
 
@@ -1565,6 +1568,7 @@ extern "C" JL_DLLEXPORT
 void jl_extern_c(jl_function_t *f, jl_value_t *rt, jl_value_t *argt, char *name)
 {
     assert(jl_is_tuple_type(argt));
+    JL_LOCK(&codegen_lock);
     Function *llvmf = jl_cfunction_object(f, rt, (jl_tupletype_t*)argt);
     // force eager emission of the function (llvm 3.3 gets confused otherwise and tries to do recursive compilation)
     uint64_t Addr = getAddressForFunction(llvmf);
@@ -1594,6 +1598,7 @@ void jl_extern_c(jl_function_t *f, jl_value_t *rt, jl_value_t *argt, char *name)
 #else
     (void)GA; (void)Addr;
 #endif
+    JL_UNLOCK(&codegen_lock);
 }
 
 // --- native code info, and dump function to IR and ASM ---
@@ -4787,6 +4792,8 @@ const struct jl_typemap_info cfunction_cache = {
 // here argt does not include the leading function type argument
 static Function *jl_cfunction_object(jl_function_t *ff, jl_value_t *declrt, jl_tupletype_t *argt)
 {
+    // Assumes the codegen lock is acquired. The caller is responsible for that.
+
     // validate and unpack the arguments
     JL_TYPECHK(cfunction, type, declrt);
     JL_TYPECHK(cfunction, type, (jl_value_t*)argt);
@@ -4856,7 +4863,6 @@ static Function *jl_cfunction_object(jl_function_t *ff, jl_value_t *declrt, jl_t
     }
 
     // Backup the info for the nested compile
-    JL_LOCK(&codegen_lock);
     IRBuilderBase::InsertPoint old = builder.saveAndClearIP();
     DebugLoc olddl = builder.getCurrentDebugLocation();
     bool last_n_c = nested_compile;
@@ -4872,7 +4878,6 @@ static Function *jl_cfunction_object(jl_function_t *ff, jl_value_t *declrt, jl_t
     builder.restoreIP(old);
     builder.SetCurrentDebugLocation(olddl);
     nested_compile = last_n_c;
-    JL_UNLOCK(&codegen_lock); // Might GC
     JL_GC_POP();
     if (f == NULL)
         jl_rethrow();
diff --git a/test/threads.jl b/test/threads.jl
index 9be402deb6..141041a14e 100644
--- a/test/threads.jl
+++ b/test/threads.jl
@@ -381,6 +381,20 @@ for period in (0.06, Dates.Millisecond(60))
     end
 end
 
+function complex_cfunction(a)
+    s = zero(eltype(a))
+    @inbounds @simd for i in a
+        s += muladd(a[i], a[i], -2)
+    end
+    return s
+end
+function test_thread_cfunction()
+    @threads for i in 1:1000
+        cfunction(complex_cfunction, Float64, Tuple{Ref{Vector{Float64}}})
+    end
+end
+test_thread_cfunction()
+
 # Compare the two ways of checking if threading is enabled.
 # `jl_tls_states` should only be defined on non-threading build.
 if ccall(:jl_threading_enabled, Cint, ()) == 0
-- 
2.12.2

