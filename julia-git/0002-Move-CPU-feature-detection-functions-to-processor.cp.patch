From 442ca3182867bb30d0dcacf54c035186e0d3ab5f Mon Sep 17 00:00:00 2001
From: Yichao Yu <yyc1992@gmail.com>
Date: Sat, 13 May 2017 16:39:59 -0400
Subject: [PATCH 2/9] Move CPU feature detection functions to processor.cpp

Use C++ instead of C since there will be a lot of string handling and indirect interaction
with LLVM in this file. The meta-programing capability is also pretty useful.
---
 src/Makefile         |   2 +-
 src/julia_internal.h |   5 ++
 src/processor.cpp    | 153 +++++++++++++++++++++++++++++++++++++++++++++++++++
 src/sys.c            | 130 -------------------------------------------
 4 files changed, 159 insertions(+), 131 deletions(-)
 create mode 100644 src/processor.cpp

diff --git a/src/Makefile b/src/Makefile
index daefd06365..439f62acb9 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -41,7 +41,7 @@ SRCS := \
 	simplevector APInt-C runtime_intrinsics runtime_ccall precompile \
 	threadgroup threading stackwalk gc gc-debug gc-pages method \
 	jlapi signal-handling safepoint jloptions timing subtype rtutils \
-	crc32c
+	crc32c processor
 
 ifeq ($(USEMSVC), 1)
 SRCS += getopt
diff --git a/src/julia_internal.h b/src/julia_internal.h
index 8d1a44c658..ece5afc1b9 100644
--- a/src/julia_internal.h
+++ b/src/julia_internal.h
@@ -734,6 +734,11 @@ void *jl_dlopen_soname(const char *pfx, size_t n, unsigned flags);
 // libuv wrappers:
 JL_DLLEXPORT int jl_fs_rename(const char *src_path, const char *dst_path);
 
+#if defined(_CPU_X86_) || defined(_CPU_X86_64_)
+JL_DLLEXPORT void jl_cpuid(int32_t CPUInfo[4], int32_t InfoType);
+JL_DLLEXPORT void jl_cpuidex(int32_t CPUInfo[4], int32_t InfoType, int32_t subInfoType);
+#endif
+
 #ifdef SEGV_EXCEPTION
 extern JL_DLLEXPORT jl_value_t *jl_segv_exception;
 #endif
diff --git a/src/processor.cpp b/src/processor.cpp
new file mode 100644
index 0000000000..d4078d680a
--- /dev/null
+++ b/src/processor.cpp
@@ -0,0 +1,153 @@
+// This file is a part of Julia. License is MIT: https://julialang.org/license
+
+// Processor feature detection
+
+#include "julia.h"
+#include "julia_internal.h"
+
+extern "C" {
+
+#if defined(_CPU_X86_) || defined(_CPU_X86_64_)
+
+// CPUID
+
+JL_DLLEXPORT void jl_cpuid(int32_t CPUInfo[4], int32_t InfoType)
+{
+#if defined _MSC_VER
+    __cpuid(CPUInfo, InfoType);
+#else
+    __asm__ __volatile__ (
+#if defined(__i386__) && defined(__PIC__)
+        "xchg %%ebx, %%esi;"
+        "cpuid;"
+        "xchg %%esi, %%ebx;" :
+        "=S" (CPUInfo[1]),
+#else
+        "cpuid" :
+        "=b" (CPUInfo[1]),
+#endif
+        "=a" (CPUInfo[0]),
+        "=c" (CPUInfo[2]),
+        "=d" (CPUInfo[3]) :
+        "a" (InfoType)
+        );
+#endif
+}
+
+JL_DLLEXPORT void jl_cpuidex(int32_t CPUInfo[4], int32_t InfoType, int32_t subInfoType)
+{
+#if defined _MSC_VER
+    __cpuidex(CPUInfo, InfoType, subInfoType);
+#else
+    __asm__ __volatile__ (
+#if defined(__i386__) && defined(__PIC__)
+        "xchg %%ebx, %%esi;"
+        "cpuid;"
+        "xchg %%esi, %%ebx;" :
+        "=S" (CPUInfo[1]),
+#else
+        "cpuid" :
+        "=b" (CPUInfo[1]),
+#endif
+        "=a" (CPUInfo[0]),
+        "=c" (CPUInfo[2]),
+        "=d" (CPUInfo[3]) :
+        "a" (InfoType),
+        "c" (subInfoType)
+        );
+#endif
+}
+
+// -- set/clear the FZ/DAZ flags on x86 & x86-64 --
+static uint32_t get_subnormal_flags(void)
+{
+    // CPU capabilities not yet inspected.
+    int32_t info[4];
+    jl_cpuid(info, 0);
+    if (info[0] >= 1) {
+        jl_cpuid(info, 1);
+        if (info[3] & (1 << 26)) {
+            // SSE2 supports both FZ and DAZ
+            return 0x00008040;
+        }
+        else if (info[3] & (1 << 25)) {
+            // SSE supports only the FZ flag
+            return 0x00008000;
+        }
+    }
+    return 0;
+}
+
+// Cache of information recovered from `cpuid` since executing `cpuid` it at runtime is slow.
+static uint32_t subnormal_flags = get_subnormal_flags();
+
+// Returns non-zero if subnormals go to 0; zero otherwise.
+JL_DLLEXPORT int32_t jl_get_zero_subnormals(void)
+{
+    return _mm_getcsr() & subnormal_flags;
+}
+
+// Return zero on success, non-zero on failure.
+JL_DLLEXPORT int32_t jl_set_zero_subnormals(int8_t isZero)
+{
+    uint32_t flags = subnormal_flags;
+    if (flags) {
+        uint32_t state = _mm_getcsr();
+        if (isZero)
+            state |= flags;
+        else
+            state &= ~flags;
+        _mm_setcsr(state);
+        return 0;
+    }
+    else {
+        // Report a failure only if user is trying to enable FTZ/DAZ.
+        return isZero;
+    }
+}
+
+#elif defined(_CPU_AARCH64_)
+
+// FZ, bit [24]
+static const uint32_t fpcr_fz_mask = 1 << 24;
+
+static inline uint32_t get_fpcr_aarch64(void)
+{
+    uint32_t fpcr;
+    asm volatile("mrs %0, fpcr" : "=r"(fpcr));
+    return fpcr;
+}
+
+static inline void set_fpcr_aarch64(uint32_t fpcr)
+{
+    asm volatile("msr fpcr, %0" :: "r"(fpcr));
+}
+
+JL_DLLEXPORT int32_t jl_get_zero_subnormals(void)
+{
+    return (get_fpcr_aarch64() & fpcr_fz_mask) != 0;
+}
+
+JL_DLLEXPORT int32_t jl_set_zero_subnormals(int8_t isZero)
+{
+    uint32_t fpcr = get_fpcr_aarch64();
+    fpcr = isZero ? (fpcr | fpcr_fz_mask) : (fpcr & ~fpcr_fz_mask);
+    set_fpcr_aarch64(fpcr);
+    return 0;
+}
+
+#else
+
+JL_DLLEXPORT int32_t jl_get_zero_subnormals(void)
+{
+    return 0;
+}
+
+JL_DLLEXPORT int32_t jl_set_zero_subnormals(int8_t isZero)
+{
+    return isZero;
+}
+
+#endif
+
+}
diff --git a/src/sys.c b/src/sys.c
index 40f0a549ad..9ed1d2b5a7 100644
--- a/src/sys.c
+++ b/src/sys.c
@@ -453,136 +453,6 @@ JL_DLLEXPORT JL_STREAM *jl_stdin_stream(void)  { return JL_STDIN; }
 JL_DLLEXPORT JL_STREAM *jl_stdout_stream(void) { return JL_STDOUT; }
 JL_DLLEXPORT JL_STREAM *jl_stderr_stream(void) { return JL_STDERR; }
 
-// CPUID
-
-#if defined(_CPU_X86_) || defined(_CPU_X86_64_)
-JL_DLLEXPORT void jl_cpuid(int32_t CPUInfo[4], int32_t InfoType)
-{
-#if defined _MSC_VER
-    __cpuid(CPUInfo, InfoType);
-#else
-    __asm__ __volatile__ (
-        #if defined(__i386__) && defined(__PIC__)
-        "xchg %%ebx, %%esi;"
-        "cpuid;"
-        "xchg %%esi, %%ebx;":
-        "=S" (CPUInfo[1]) ,
-        #else
-        "cpuid":
-        "=b" (CPUInfo[1]),
-        #endif
-        "=a" (CPUInfo[0]),
-        "=c" (CPUInfo[2]),
-        "=d" (CPUInfo[3]) :
-        "a" (InfoType)
-    );
-#endif
-}
-#endif
-
-// -- set/clear the FZ/DAZ flags on x86 & x86-64 --
-#ifdef __SSE__
-
-// Cache of information recovered from jl_cpuid.
-// In a multithreaded environment, there will be races on subnormal_flags,
-// but they are harmless idempotent races.  If we ever embrace C11, then
-// subnormal_flags should be declared atomic.
-static volatile int32_t subnormal_flags = 1;
-
-static int32_t get_subnormal_flags(void)
-{
-    uint32_t f = subnormal_flags;
-    if (f & 1) {
-        // CPU capabilities not yet inspected.
-        f = 0;
-        int32_t info[4];
-        jl_cpuid(info, 0);
-        if (info[0] >= 1) {
-            jl_cpuid(info, 0x00000001);
-            if (info[3] & (1 << 26)) {
-                // SSE2 supports both FZ and DAZ
-                f = 0x00008040;
-            }
-            else if (info[3] & (1 << 25)) {
-                // SSE supports only the FZ flag
-                f = 0x00008000;
-            }
-        }
-        subnormal_flags = f;
-    }
-    return f;
-}
-
-// Returns non-zero if subnormals go to 0; zero otherwise.
-JL_DLLEXPORT int32_t jl_get_zero_subnormals(void)
-{
-    uint32_t flags = get_subnormal_flags();
-    return _mm_getcsr() & flags;
-}
-
-// Return zero on success, non-zero on failure.
-JL_DLLEXPORT int32_t jl_set_zero_subnormals(int8_t isZero)
-{
-    uint32_t flags = get_subnormal_flags();
-    if (flags) {
-        uint32_t state = _mm_getcsr();
-        if (isZero)
-            state |= flags;
-        else
-            state &= ~flags;
-        _mm_setcsr(state);
-        return 0;
-    }
-    else {
-        // Report a failure only if user is trying to enable FTZ/DAZ.
-        return isZero;
-    }
-}
-
-#elif defined(_CPU_AARCH64_)
-
-// FZ, bit [24]
-static const uint32_t fpcr_fz_mask = 1 << 24;
-
-static inline uint32_t get_fpcr_aarch64(void)
-{
-    uint32_t fpcr;
-    asm volatile("mrs %0, fpcr" : "=r"(fpcr));
-    return fpcr;
-}
-
-static inline void set_fpcr_aarch64(uint32_t fpcr)
-{
-    asm volatile("msr fpcr, %0" :: "r"(fpcr));
-}
-
-JL_DLLEXPORT int32_t jl_get_zero_subnormals(void)
-{
-    return (get_fpcr_aarch64() & fpcr_fz_mask) != 0;
-}
-
-JL_DLLEXPORT int32_t jl_set_zero_subnormals(int8_t isZero)
-{
-    uint32_t fpcr = get_fpcr_aarch64();
-    fpcr = isZero ? (fpcr | fpcr_fz_mask) : (fpcr & ~fpcr_fz_mask);
-    set_fpcr_aarch64(fpcr);
-    return 0;
-}
-
-#else
-
-JL_DLLEXPORT int32_t jl_get_zero_subnormals(void)
-{
-    return 0;
-}
-
-JL_DLLEXPORT int32_t jl_set_zero_subnormals(int8_t isZero)
-{
-    return isZero;
-}
-
-#endif
-
 // -- processor native alignment information --
 
 JL_DLLEXPORT void jl_native_alignment(uint_t *int8align, uint_t *int16align, uint_t *int32align,
-- 
2.14.2

