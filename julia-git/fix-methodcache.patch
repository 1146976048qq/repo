From a997e14ee2e7377beb299b9f3ce966293624eebe Mon Sep 17 00:00:00 2001
From: Jameson Nash <vtjnash@gmail.com>
Date: Thu, 4 Aug 2016 14:42:30 -0400
Subject: [PATCH] fix deserializer jl_recache_type to walk type parameter list
 completely

previously, it only walked through types with `uid = -1`,
but in fact we needed to walk through any uncached type,
including those with `uid = 0` and those gotten from jl_typeof

fix #17809
---
 src/dump.c      | 53 ++++++++++++++++++++++++++++++++---------------------
 test/compile.jl | 16 ++++++++++++++++
 2 files changed, 48 insertions(+), 21 deletions(-)

diff --git a/src/dump.c b/src/dump.c
index d0e3f88..7157d89 100644
--- a/src/dump.c
+++ b/src/dump.c
@@ -2222,35 +2222,46 @@ static jl_datatype_t *jl_recache_type(jl_datatype_t *dt, size_t start, jl_value_
 {
     if (v == NULL)
         v = dt->instance; // the instance before unique'ing
-    jl_datatype_t *t; // the type after unique'ing
-    if (dt->uid == -1) {
-        jl_svec_t *tt = dt->parameters;
-        size_t l = jl_svec_len(tt);
-        if (l == 0) { // jl_cache_type doesn't work if length(parameters) == 0
-            dt->uid = jl_assign_type_uid();
-            t = dt;
-        }
-        else {
-            // recache all type parameters, then type type itself
-            size_t i;
-            for (i = 0; i < l; i++) {
-                jl_datatype_t *p = (jl_datatype_t*)jl_svecref(tt, i);
-                if (jl_is_datatype(p) && p->uid == -1) {
+    jl_svec_t *tt = dt->parameters;
+    if (dt->uid == 0 || dt->uid == -1) {
+        // recache all type parameters
+        size_t i, l = jl_svec_len(tt);
+        for (i = 0; i < l; i++) {
+            jl_datatype_t *p = (jl_datatype_t*)jl_svecref(tt, i);
+            if (jl_is_datatype(p)) {
+                if (p->uid == -1 || p->uid == 0) {
                     jl_datatype_t *cachep = jl_recache_type(p, start, NULL);
-                    if (p != cachep)
+                    if (p != cachep) {
+                        assert(jl_types_equal((jl_value_t*)p, (jl_value_t*)cachep));
                         jl_svecset(tt, i, cachep);
+                    }
                 }
+            }
+            else {
                 jl_datatype_t *tp = (jl_datatype_t*)jl_typeof(p);
-                if (jl_is_datatype_singleton(tp)) {
-                    if (tp->uid == -1) {
-                        tp = jl_recache_type(tp, start, NULL);
-                    }
-                    if ((jl_value_t*)p != tp->instance)
-                        jl_svecset(tt, i, tp->instance);
+                assert(tp->uid != 0);
+                if (tp->uid == -1) {
+                    tp = jl_recache_type(tp, start, NULL);
                 }
+                if (tp->instance && (jl_value_t*)p != tp->instance)
+                    jl_svecset(tt, i, tp->instance);
             }
+        }
+    }
+
+    jl_datatype_t *t; // the type after unique'ing
+    if (dt->uid == 0) {
+        return dt;
+    }
+    else if (dt->uid == -1) {
+        if (jl_svec_len(tt) == 0) { // jl_cache_type doesn't work if length(parameters) == 0
+            dt->uid = jl_assign_type_uid();
+            t = dt;
+        }
+        else {
             dt->uid = 0;
             t = (jl_datatype_t*)jl_cache_type_(dt);
+            assert(jl_types_equal((jl_value_t*)t, (jl_value_t*)dt));
         }
     }
     else {
diff --git a/test/compile.jl b/test/compile.jl
index ce76821..4134304 100644
--- a/test/compile.jl
+++ b/test/compile.jl
@@ -31,6 +31,16 @@ try
                   include_dependency("bar.jl")
               end
 
+              # test for creation of some reasonably complicated type
+              immutable MyInt8{T}
+                  x::T
+              end
+              t17809 = Val{Type{Tuple{Ptr{MyInt8{1}},
+                                      Ptr{MyInt8{MyInt8(0)}}(0),
+                                      Complex{Int}(1, 2),
+                                      3,
+                                      nothing}}}()
+
               # test that types and methods get reconnected correctly
               # issue 16529 (adding a method to a type with no instances)
               (::Task)(::UInt8, ::UInt16, ::UInt32) = 2
@@ -110,6 +120,12 @@ try
         @test Vector{Foo.NominalValue{Int32, Int64}}() == 3
         @test Vector{Foo.NominalValue{UInt, UInt}}() == 4
         @test Vector{Foo.NominalValue{Int, Int}}() == 5
+        @test Foo.t17809 === typeof(Foo.t17809)()
+        @test Foo.t17809 === Val{Type{Tuple{Ptr{Foo.MyInt8{1}},
+                                      Ptr{Foo.MyInt8{Foo.MyInt8(0)}}(0),
+                                      Complex{Int}(1, 2),
+                                      3,
+                                      nothing}}}()
     end
 
     Baz_file = joinpath(dir, "Baz.jl")
