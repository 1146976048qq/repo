From 9fe394feba1cf1496c534cef93bb126d000c148e Mon Sep 17 00:00:00 2001
From: Yichao Yu <yyc1992@gmail.com>
Date: Sat, 29 Aug 2020 10:32:00 -0400
Subject: [PATCH] Allow specifying AA info when constructing certain libcalls

Maintain such info when simplifying libcalls.
---
 include/llvm/Transforms/Utils/BuildLibCalls.h | 110 ++++--
 .../llvm/Transforms/Utils/SimplifyLibCalls.h  |   2 +-
 lib/Transforms/Utils/BuildLibCalls.cpp        | 249 ++++++++++---
 lib/Transforms/Utils/SimplifyLibCalls.cpp     | 336 ++++++++++++------
 4 files changed, 528 insertions(+), 169 deletions(-)

diff --git a/include/llvm/Transforms/Utils/BuildLibCalls.h b/include/llvm/Transforms/Utils/BuildLibCalls.h
index 90517e806e0..66ae11e5d8a 100644
--- a/include/llvm/Transforms/Utils/BuildLibCalls.h
+++ b/include/llvm/Transforms/Utils/BuildLibCalls.h
@@ -47,102 +47,170 @@ namespace llvm {
   /// pointer. Ptr is required to be some pointer type, and the return value has
   /// 'intptr_t' type.
   Value *emitStrLen(Value *Ptr, IRBuilderBase &B, const DataLayout &DL,
-                    const TargetLibraryInfo *TLI);
+                    const TargetLibraryInfo *TLI,
+                    const AAMDNodes &AAInfo);
 
   /// Emit a call to the strdup function to the builder, for the specified
   /// pointer. Ptr is required to be some pointer type, and the return value has
   /// 'i8*' type.
-  Value *emitStrDup(Value *Ptr, IRBuilderBase &B, const TargetLibraryInfo *TLI);
+  Value *emitStrDup(Value *Ptr, IRBuilderBase &B, const TargetLibraryInfo *TLI,
+                    const AAMDNodes &AAInfo);
 
   /// Emit a call to the strnlen function to the builder, for the specified
   /// pointer. Ptr is required to be some pointer type, MaxLen must be of size_t
   /// type, and the return value has 'intptr_t' type.
   Value *emitStrNLen(Value *Ptr, Value *MaxLen, IRBuilderBase &B,
-                     const DataLayout &DL, const TargetLibraryInfo *TLI);
+                     const DataLayout &DL, const TargetLibraryInfo *TLI,
+                     const AAMDNodes &AAInfo);
 
   /// Emit a call to the strchr function to the builder, for the specified
   /// pointer and character. Ptr is required to be some pointer type, and the
   /// return value has 'i8*' type.
   Value *emitStrChr(Value *Ptr, char C, IRBuilderBase &B,
-                    const TargetLibraryInfo *TLI);
+                    const TargetLibraryInfo *TLI,
+                    const AAMDNodes &AAInfo);
 
   /// Emit a call to the strncmp function to the builder.
   Value *emitStrNCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilderBase &B,
-                     const DataLayout &DL, const TargetLibraryInfo *TLI);
+                     const DataLayout &DL, const TargetLibraryInfo *TLI,
+                     const AAMDNodes &AAInfo);
 
   /// Emit a call to the strcpy function to the builder, for the specified
   /// pointer arguments.
   Value *emitStrCpy(Value *Dst, Value *Src, IRBuilderBase &B,
-                    const TargetLibraryInfo *TLI);
+                    const TargetLibraryInfo *TLI,
+                    const AAMDNodes &AAInfo);
 
   /// Emit a call to the stpcpy function to the builder, for the specified
   /// pointer arguments.
   Value *emitStpCpy(Value *Dst, Value *Src, IRBuilderBase &B,
-                    const TargetLibraryInfo *TLI);
+                    const TargetLibraryInfo *TLI,
+                    const AAMDNodes &AAInfo);
 
   /// Emit a call to the strncpy function to the builder, for the specified
   /// pointer arguments and length.
   Value *emitStrNCpy(Value *Dst, Value *Src, Value *Len, IRBuilderBase &B,
-                     const TargetLibraryInfo *TLI);
+                     const TargetLibraryInfo *TLI,
+                     const AAMDNodes &AAInfo);
 
   /// Emit a call to the stpncpy function to the builder, for the specified
   /// pointer arguments and length.
   Value *emitStpNCpy(Value *Dst, Value *Src, Value *Len, IRBuilderBase &B,
-                     const TargetLibraryInfo *TLI);
+                     const TargetLibraryInfo *TLI,
+                     const AAMDNodes &AAInfo);
 
   /// Emit a call to the __memcpy_chk function to the builder. This expects that
   /// the Len and ObjSize have type 'intptr_t' and Dst/Src are pointers.
   Value *emitMemCpyChk(Value *Dst, Value *Src, Value *Len, Value *ObjSize,
                        IRBuilderBase &B, const DataLayout &DL,
-                       const TargetLibraryInfo *TLI);
+                       const TargetLibraryInfo *TLI,
+                       const AAMDNodes &AAInfo);
 
   /// Emit a call to the memchr function. This assumes that Ptr is a pointer,
   /// Val is an i32 value, and Len is an 'intptr_t' value.
   Value *emitMemChr(Value *Ptr, Value *Val, Value *Len, IRBuilderBase &B,
-                    const DataLayout &DL, const TargetLibraryInfo *TLI);
+                    const DataLayout &DL, const TargetLibraryInfo *TLI,
+                    const AAMDNodes &AAInfo);
 
   /// Emit a call to the memcmp function.
   Value *emitMemCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilderBase &B,
-                    const DataLayout &DL, const TargetLibraryInfo *TLI);
+                    const DataLayout &DL, const TargetLibraryInfo *TLI,
+                    const AAMDNodes &AAInfo);
 
   /// Emit a call to the bcmp function.
   Value *emitBCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilderBase &B,
-                  const DataLayout &DL, const TargetLibraryInfo *TLI);
+                  const DataLayout &DL, const TargetLibraryInfo *TLI,
+                  const AAMDNodes &AAInfo);
 
   /// Emit a call to the memccpy function.
   Value *emitMemCCpy(Value *Ptr1, Value *Ptr2, Value *Val, Value *Len,
-                     IRBuilderBase &B, const TargetLibraryInfo *TLI);
+                     IRBuilderBase &B, const TargetLibraryInfo *TLI,
+                     const AAMDNodes &AAInfo);
 
   /// Emit a call to the snprintf function.
   Value *emitSNPrintf(Value *Dest, Value *Size, Value *Fmt,
                       ArrayRef<Value *> Args, IRBuilderBase &B,
-                      const TargetLibraryInfo *TLI);
+                      const TargetLibraryInfo *TLI,
+                      const AAMDNodes &AAInfo);
 
   /// Emit a call to the sprintf function.
   Value *emitSPrintf(Value *Dest, Value *Fmt, ArrayRef<Value *> VariadicArgs,
-                     IRBuilderBase &B, const TargetLibraryInfo *TLI);
+                     IRBuilderBase &B, const TargetLibraryInfo *TLI,
+                     const AAMDNodes &AAInfo);
 
   /// Emit a call to the strcat function.
   Value *emitStrCat(Value *Dest, Value *Src, IRBuilderBase &B,
-                    const TargetLibraryInfo *TLI);
+                    const TargetLibraryInfo *TLI,
+                    const AAMDNodes &AAInfo);
 
   /// Emit a call to the strlcpy function.
   Value *emitStrLCpy(Value *Dest, Value *Src, Value *Size, IRBuilderBase &B,
-                     const TargetLibraryInfo *TLI);
+                     const TargetLibraryInfo *TLI,
+                     const AAMDNodes &AAInfo);
 
   /// Emit a call to the strlcat function.
   Value *emitStrLCat(Value *Dest, Value *Src, Value *Size, IRBuilderBase &B,
-                     const TargetLibraryInfo *TLI);
+                     const TargetLibraryInfo *TLI,
+                     const AAMDNodes &AAInfo);
 
   /// Emit a call to the strncat function.
   Value *emitStrNCat(Value *Dest, Value *Src, Value *Size, IRBuilderBase &B,
-                     const TargetLibraryInfo *TLI);
+                     const TargetLibraryInfo *TLI,
+                     const AAMDNodes &AAInfo);
 
   /// Emit a call to the vsnprintf function.
   Value *emitVSNPrintf(Value *Dest, Value *Size, Value *Fmt, Value *VAList,
-                       IRBuilderBase &B, const TargetLibraryInfo *TLI);
+                       IRBuilderBase &B, const TargetLibraryInfo *TLI,
+                       const AAMDNodes &AAInfo);
 
   /// Emit a call to the vsprintf function.
+  Value *emitVSPrintf(Value *Dest, Value *Fmt, Value *VAList, IRBuilderBase &B,
+                      const TargetLibraryInfo *TLI,
+                      const AAMDNodes &AAInfo);
+
+  Value *emitStrLen(Value *Ptr, IRBuilderBase &B, const DataLayout &DL,
+                    const TargetLibraryInfo *TLI);
+  Value *emitStrDup(Value *Ptr, IRBuilderBase &B, const TargetLibraryInfo *TLI);
+  Value *emitStrNLen(Value *Ptr, Value *MaxLen, IRBuilderBase &B,
+                     const DataLayout &DL, const TargetLibraryInfo *TLI);
+  Value *emitStrChr(Value *Ptr, char C, IRBuilderBase &B,
+                    const TargetLibraryInfo *TLI);
+  Value *emitStrNCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilderBase &B,
+                     const DataLayout &DL, const TargetLibraryInfo *TLI);
+  Value *emitStrCpy(Value *Dst, Value *Src, IRBuilderBase &B,
+                    const TargetLibraryInfo *TLI);
+  Value *emitStpCpy(Value *Dst, Value *Src, IRBuilderBase &B,
+                    const TargetLibraryInfo *TLI);
+  Value *emitStrNCpy(Value *Dst, Value *Src, Value *Len, IRBuilderBase &B,
+                     const TargetLibraryInfo *TLI);
+  Value *emitStpNCpy(Value *Dst, Value *Src, Value *Len, IRBuilderBase &B,
+                     const TargetLibraryInfo *TLI);
+  Value *emitMemCpyChk(Value *Dst, Value *Src, Value *Len, Value *ObjSize,
+                       IRBuilderBase &B, const DataLayout &DL,
+                       const TargetLibraryInfo *TLI);
+  Value *emitMemChr(Value *Ptr, Value *Val, Value *Len, IRBuilderBase &B,
+                    const DataLayout &DL, const TargetLibraryInfo *TLI);
+  Value *emitMemCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilderBase &B,
+                    const DataLayout &DL, const TargetLibraryInfo *TLI);
+  Value *emitBCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilderBase &B,
+                  const DataLayout &DL, const TargetLibraryInfo *TLI);
+  Value *emitMemCCpy(Value *Ptr1, Value *Ptr2, Value *Val, Value *Len,
+                     IRBuilderBase &B, const TargetLibraryInfo *TLI);
+  Value *emitSNPrintf(Value *Dest, Value *Size, Value *Fmt,
+                      ArrayRef<Value *> Args, IRBuilderBase &B,
+                      const TargetLibraryInfo *TLI);
+  Value *emitSPrintf(Value *Dest, Value *Fmt, ArrayRef<Value *> VariadicArgs,
+                     IRBuilderBase &B, const TargetLibraryInfo *TLI);
+  Value *emitStrCat(Value *Dest, Value *Src, IRBuilderBase &B,
+                    const TargetLibraryInfo *TLI);
+  Value *emitStrLCpy(Value *Dest, Value *Src, Value *Size, IRBuilderBase &B,
+                     const TargetLibraryInfo *TLI);
+  Value *emitStrLCat(Value *Dest, Value *Src, Value *Size, IRBuilderBase &B,
+                     const TargetLibraryInfo *TLI);
+  Value *emitStrNCat(Value *Dest, Value *Src, Value *Size, IRBuilderBase &B,
+                     const TargetLibraryInfo *TLI);
+  Value *emitVSNPrintf(Value *Dest, Value *Size, Value *Fmt, Value *VAList,
+                       IRBuilderBase &B, const TargetLibraryInfo *TLI);
   Value *emitVSPrintf(Value *Dest, Value *Fmt, Value *VAList, IRBuilderBase &B,
                       const TargetLibraryInfo *TLI);
 
diff --git a/include/llvm/Transforms/Utils/SimplifyLibCalls.h b/include/llvm/Transforms/Utils/SimplifyLibCalls.h
index d6ee19365c7..10f55730c57 100644
--- a/include/llvm/Transforms/Utils/SimplifyLibCalls.h
+++ b/include/llvm/Transforms/Utils/SimplifyLibCalls.h
@@ -224,7 +224,7 @@ private:
 
   // Helper methods
   Value *emitStrLenMemCpy(Value *Src, Value *Dst, uint64_t Len,
-                          IRBuilderBase &B);
+                          IRBuilderBase &B, const AAMDNodes &AATags);
   void classifyArgUse(Value *Val, Function *F, bool IsFloat,
                       SmallVectorImpl<CallInst *> &SinCalls,
                       SmallVectorImpl<CallInst *> &CosCalls,
diff --git a/lib/Transforms/Utils/BuildLibCalls.cpp b/lib/Transforms/Utils/BuildLibCalls.cpp
index c64ad147fdf..efb47b799b5 100644
--- a/lib/Transforms/Utils/BuildLibCalls.cpp
+++ b/lib/Transforms/Utils/BuildLibCalls.cpp
@@ -828,11 +828,143 @@ Value *llvm::castToCStr(Value *V, IRBuilderBase &B) {
   return B.CreateBitCast(V, B.getInt8PtrTy(AS), "cstr");
 }
 
+Value *llvm::emitStrLen(Value *Ptr, IRBuilderBase &B, const DataLayout &DL,
+                        const TargetLibraryInfo *TLI)
+{
+    return emitStrLen(Ptr, B, DL, TLI, AAMDNodes());
+}
+
+Value *llvm::emitStrDup(Value *Ptr, IRBuilderBase &B, const TargetLibraryInfo *TLI)
+{
+    return emitStrDup(Ptr, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitStrNLen(Value *Ptr, Value *MaxLen, IRBuilderBase &B,
+                         const DataLayout &DL, const TargetLibraryInfo *TLI)
+{
+    return emitStrNLen(Ptr, MaxLen, B, DL, TLI, AAMDNodes());
+}
+
+Value *llvm::emitStrChr(Value *Ptr, char C, IRBuilderBase &B,
+                        const TargetLibraryInfo *TLI)
+{
+    return emitStrChr(Ptr, C, B, TLI, AAMDNodes());
+}
+Value *llvm::emitStrNCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilderBase &B,
+                         const DataLayout &DL, const TargetLibraryInfo *TLI)
+{
+    return emitStrNCmp(Ptr1, Ptr2, Len, B, DL, TLI, AAMDNodes());
+}
+
+Value *llvm::emitStrCpy(Value *Dst, Value *Src, IRBuilderBase &B,
+                        const TargetLibraryInfo *TLI)
+{
+    return emitStrCpy(Dst, Src, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitStpCpy(Value *Dst, Value *Src, IRBuilderBase &B,
+                        const TargetLibraryInfo *TLI)
+{
+    return emitStpCpy(Dst, Src, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitStrNCpy(Value *Dst, Value *Src, Value *Len, IRBuilderBase &B,
+                         const TargetLibraryInfo *TLI)
+{
+    return emitStrNCpy(Dst, Src, Len, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitStpNCpy(Value *Dst, Value *Src, Value *Len, IRBuilderBase &B,
+                         const TargetLibraryInfo *TLI)
+{
+    return emitStpNCpy(Dst, Src, Len, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitMemCpyChk(Value *Dst, Value *Src, Value *Len, Value *ObjSize,
+                           IRBuilderBase &B, const DataLayout &DL,
+                           const TargetLibraryInfo *TLI)
+{
+    return emitMemCpyChk(Dst, Src, Len, ObjSize, B, DL, TLI, AAMDNodes());
+}
+
+Value *llvm::emitMemChr(Value *Ptr, Value *Val, Value *Len, IRBuilderBase &B,
+                        const DataLayout &DL, const TargetLibraryInfo *TLI)
+{
+    return emitMemChr(Ptr, Val, Len, B, DL, TLI, AAMDNodes());
+}
+
+Value *llvm::emitMemCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilderBase &B,
+                        const DataLayout &DL, const TargetLibraryInfo *TLI)
+{
+    return emitMemCmp(Ptr1, Ptr2, Len, B, DL, TLI, AAMDNodes());
+}
+
+Value *llvm::emitBCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilderBase &B,
+                      const DataLayout &DL, const TargetLibraryInfo *TLI)
+{
+    return emitBCmp(Ptr1, Ptr2, Len, B, DL, TLI, AAMDNodes());
+}
+
+Value *llvm::emitMemCCpy(Value *Ptr1, Value *Ptr2, Value *Val, Value *Len,
+                         IRBuilderBase &B, const TargetLibraryInfo *TLI)
+{
+    return emitMemCCpy(Ptr1, Ptr2, Val, Len, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitSNPrintf(Value *Dest, Value *Size, Value *Fmt,
+                          ArrayRef<Value *> Args, IRBuilderBase &B,
+                          const TargetLibraryInfo *TLI)
+{
+    return emitSNPrintf(Dest, Size, Fmt, Args, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitSPrintf(Value *Dest, Value *Fmt, ArrayRef<Value *> VariadicArgs,
+                         IRBuilderBase &B, const TargetLibraryInfo *TLI)
+{
+    return emitSPrintf(Dest, Fmt, VariadicArgs, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitStrCat(Value *Dest, Value *Src, IRBuilderBase &B,
+                        const TargetLibraryInfo *TLI)
+{
+    return emitStrCat(Dest, Src, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitStrLCpy(Value *Dest, Value *Src, Value *Size, IRBuilderBase &B,
+                         const TargetLibraryInfo *TLI)
+{
+    return emitStrLCpy(Dest, Src, Size, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitStrLCat(Value *Dest, Value *Src, Value *Size, IRBuilderBase &B,
+                         const TargetLibraryInfo *TLI)
+{
+    return emitStrLCat(Dest, Src, Size, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitStrNCat(Value *Dest, Value *Src, Value *Size, IRBuilderBase &B,
+                         const TargetLibraryInfo *TLI)
+{
+    return emitStrNCat(Dest, Src, Size, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitVSNPrintf(Value *Dest, Value *Size, Value *Fmt, Value *VAList,
+                           IRBuilderBase &B, const TargetLibraryInfo *TLI)
+{
+    return emitVSNPrintf(Dest, Size, Fmt, VAList, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitVSPrintf(Value *Dest, Value *Fmt, Value *VAList, IRBuilderBase &B,
+                          const TargetLibraryInfo *TLI)
+{
+    return emitVSPrintf(Dest, Fmt, VAList, B, TLI, AAMDNodes());
+}
+
 static Value *emitLibCall(LibFunc TheLibFunc, Type *ReturnType,
                           ArrayRef<Type *> ParamTypes,
                           ArrayRef<Value *> Operands, IRBuilderBase &B,
-                          const TargetLibraryInfo *TLI,
-                          bool IsVaArgs = false) {
+                          const TargetLibraryInfo *TLI, bool IsVaArgs = false,
+                          const AAMDNodes &AAInfo = AAMDNodes()) {
   if (!TLI->has(TheLibFunc))
     return nullptr;
 
@@ -845,70 +977,79 @@ static Value *emitLibCall(LibFunc TheLibFunc, Type *ReturnType,
   if (const Function *F =
           dyn_cast<Function>(Callee.getCallee()->stripPointerCasts()))
     CI->setCallingConv(F->getCallingConv());
+  CI->setAAMetadata(AAInfo);
   return CI;
 }
 
 Value *llvm::emitStrLen(Value *Ptr, IRBuilderBase &B, const DataLayout &DL,
-                        const TargetLibraryInfo *TLI) {
+                        const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   LLVMContext &Context = B.GetInsertBlock()->getContext();
   return emitLibCall(LibFunc_strlen, DL.getIntPtrType(Context),
-                     B.getInt8PtrTy(), castToCStr(Ptr, B), B, TLI);
+                     B.getInt8PtrTy(), castToCStr(Ptr, B), B, TLI, false,
+                     AAInfo);
 }
 
 Value *llvm::emitStrDup(Value *Ptr, IRBuilderBase &B,
-                        const TargetLibraryInfo *TLI) {
+                        const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   return emitLibCall(LibFunc_strdup, B.getInt8PtrTy(), B.getInt8PtrTy(),
-                     castToCStr(Ptr, B), B, TLI);
+                     castToCStr(Ptr, B), B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitStrChr(Value *Ptr, char C, IRBuilderBase &B,
-                        const TargetLibraryInfo *TLI) {
+                        const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   Type *I8Ptr = B.getInt8PtrTy();
   Type *I32Ty = B.getInt32Ty();
   return emitLibCall(LibFunc_strchr, I8Ptr, {I8Ptr, I32Ty},
-                     {castToCStr(Ptr, B), ConstantInt::get(I32Ty, C)}, B, TLI);
+                     {castToCStr(Ptr, B), ConstantInt::get(I32Ty, C)}, B, TLI,
+                     false, AAInfo);
 }
 
 Value *llvm::emitStrNCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilderBase &B,
-                         const DataLayout &DL, const TargetLibraryInfo *TLI) {
+                         const DataLayout &DL, const TargetLibraryInfo *TLI,
+                         const AAMDNodes &AAInfo) {
   LLVMContext &Context = B.GetInsertBlock()->getContext();
   return emitLibCall(
       LibFunc_strncmp, B.getInt32Ty(),
       {B.getInt8PtrTy(), B.getInt8PtrTy(), DL.getIntPtrType(Context)},
-      {castToCStr(Ptr1, B), castToCStr(Ptr2, B), Len}, B, TLI);
+      {castToCStr(Ptr1, B), castToCStr(Ptr2, B), Len}, B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitStrCpy(Value *Dst, Value *Src, IRBuilderBase &B,
-                        const TargetLibraryInfo *TLI) {
+                        const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   Type *I8Ptr = B.getInt8PtrTy();
   return emitLibCall(LibFunc_strcpy, I8Ptr, {I8Ptr, I8Ptr},
-                     {castToCStr(Dst, B), castToCStr(Src, B)}, B, TLI);
+                     {castToCStr(Dst, B), castToCStr(Src, B)}, B, TLI,
+                     false, AAInfo);
 }
 
 Value *llvm::emitStpCpy(Value *Dst, Value *Src, IRBuilderBase &B,
-                        const TargetLibraryInfo *TLI) {
+                        const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   Type *I8Ptr = B.getInt8PtrTy();
   return emitLibCall(LibFunc_stpcpy, I8Ptr, {I8Ptr, I8Ptr},
-                     {castToCStr(Dst, B), castToCStr(Src, B)}, B, TLI);
+                     {castToCStr(Dst, B), castToCStr(Src, B)}, B, TLI,
+                     false, AAInfo);
 }
 
 Value *llvm::emitStrNCpy(Value *Dst, Value *Src, Value *Len, IRBuilderBase &B,
-                         const TargetLibraryInfo *TLI) {
+                         const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   Type *I8Ptr = B.getInt8PtrTy();
   return emitLibCall(LibFunc_strncpy, I8Ptr, {I8Ptr, I8Ptr, Len->getType()},
-                     {castToCStr(Dst, B), castToCStr(Src, B), Len}, B, TLI);
+                     {castToCStr(Dst, B), castToCStr(Src, B), Len}, B, TLI,
+                     false, AAInfo);
 }
 
 Value *llvm::emitStpNCpy(Value *Dst, Value *Src, Value *Len, IRBuilderBase &B,
-                         const TargetLibraryInfo *TLI) {
+                         const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   Type *I8Ptr = B.getInt8PtrTy();
   return emitLibCall(LibFunc_stpncpy, I8Ptr, {I8Ptr, I8Ptr, Len->getType()},
-                     {castToCStr(Dst, B), castToCStr(Src, B), Len}, B, TLI);
+                     {castToCStr(Dst, B), castToCStr(Src, B), Len}, B, TLI,
+                     false, AAInfo);
 }
 
 Value *llvm::emitMemCpyChk(Value *Dst, Value *Src, Value *Len, Value *ObjSize,
                            IRBuilderBase &B, const DataLayout &DL,
-                           const TargetLibraryInfo *TLI) {
+                           const TargetLibraryInfo *TLI,
+                           const AAMDNodes &AAInfo) {
   if (!TLI->has(LibFunc_memcpy_chk))
     return nullptr;
 
@@ -927,105 +1068,123 @@ Value *llvm::emitMemCpyChk(Value *Dst, Value *Src, Value *Len, Value *ObjSize,
   if (const Function *F =
           dyn_cast<Function>(MemCpy.getCallee()->stripPointerCasts()))
     CI->setCallingConv(F->getCallingConv());
+  CI->setAAMetadata(AAInfo);
   return CI;
 }
 
 Value *llvm::emitMemChr(Value *Ptr, Value *Val, Value *Len, IRBuilderBase &B,
-                        const DataLayout &DL, const TargetLibraryInfo *TLI) {
+                        const DataLayout &DL, const TargetLibraryInfo *TLI,
+                        const AAMDNodes &AAInfo) {
   LLVMContext &Context = B.GetInsertBlock()->getContext();
   return emitLibCall(
       LibFunc_memchr, B.getInt8PtrTy(),
       {B.getInt8PtrTy(), B.getInt32Ty(), DL.getIntPtrType(Context)},
-      {castToCStr(Ptr, B), Val, Len}, B, TLI);
+      {castToCStr(Ptr, B), Val, Len}, B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitMemCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilderBase &B,
-                        const DataLayout &DL, const TargetLibraryInfo *TLI) {
+                        const DataLayout &DL, const TargetLibraryInfo *TLI,
+                        const AAMDNodes &AAInfo) {
   LLVMContext &Context = B.GetInsertBlock()->getContext();
   return emitLibCall(
       LibFunc_memcmp, B.getInt32Ty(),
       {B.getInt8PtrTy(), B.getInt8PtrTy(), DL.getIntPtrType(Context)},
-      {castToCStr(Ptr1, B), castToCStr(Ptr2, B), Len}, B, TLI);
+      {castToCStr(Ptr1, B), castToCStr(Ptr2, B), Len}, B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitBCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilderBase &B,
-                      const DataLayout &DL, const TargetLibraryInfo *TLI) {
+                      const DataLayout &DL, const TargetLibraryInfo *TLI,
+                      const AAMDNodes &AAInfo) {
   LLVMContext &Context = B.GetInsertBlock()->getContext();
   return emitLibCall(
       LibFunc_bcmp, B.getInt32Ty(),
       {B.getInt8PtrTy(), B.getInt8PtrTy(), DL.getIntPtrType(Context)},
-      {castToCStr(Ptr1, B), castToCStr(Ptr2, B), Len}, B, TLI);
+      {castToCStr(Ptr1, B), castToCStr(Ptr2, B), Len}, B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitMemCCpy(Value *Ptr1, Value *Ptr2, Value *Val, Value *Len,
-                         IRBuilderBase &B, const TargetLibraryInfo *TLI) {
+                         IRBuilderBase &B, const TargetLibraryInfo *TLI,
+                         const AAMDNodes &AAInfo) {
   return emitLibCall(
       LibFunc_memccpy, B.getInt8PtrTy(),
       {B.getInt8PtrTy(), B.getInt8PtrTy(), B.getInt32Ty(), Len->getType()},
-      {Ptr1, Ptr2, Val, Len}, B, TLI);
+      {Ptr1, Ptr2, Val, Len}, B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitSNPrintf(Value *Dest, Value *Size, Value *Fmt,
                           ArrayRef<Value *> VariadicArgs, IRBuilderBase &B,
-                          const TargetLibraryInfo *TLI) {
+                          const TargetLibraryInfo *TLI,
+                          const AAMDNodes &AAInfo) {
   SmallVector<Value *, 8> Args{castToCStr(Dest, B), Size, castToCStr(Fmt, B)};
   Args.insert(Args.end(), VariadicArgs.begin(), VariadicArgs.end());
   return emitLibCall(LibFunc_snprintf, B.getInt32Ty(),
                      {B.getInt8PtrTy(), Size->getType(), B.getInt8PtrTy()},
-                     Args, B, TLI, /*IsVaArgs=*/true);
+                     Args, B, TLI, /*IsVaArgs=*/true, AAInfo);
 }
 
 Value *llvm::emitSPrintf(Value *Dest, Value *Fmt,
                          ArrayRef<Value *> VariadicArgs, IRBuilderBase &B,
-                         const TargetLibraryInfo *TLI) {
+                         const TargetLibraryInfo *TLI,
+                         const AAMDNodes &AAInfo) {
   SmallVector<Value *, 8> Args{castToCStr(Dest, B), castToCStr(Fmt, B)};
   Args.insert(Args.end(), VariadicArgs.begin(), VariadicArgs.end());
   return emitLibCall(LibFunc_sprintf, B.getInt32Ty(),
                      {B.getInt8PtrTy(), B.getInt8PtrTy()}, Args, B, TLI,
-                     /*IsVaArgs=*/true);
+                     /*IsVaArgs=*/true, AAInfo);
 }
 
 Value *llvm::emitStrCat(Value *Dest, Value *Src, IRBuilderBase &B,
-                        const TargetLibraryInfo *TLI) {
-  return emitLibCall(LibFunc_strcat, B.getInt8PtrTy(),
-                     {B.getInt8PtrTy(), B.getInt8PtrTy()},
-                     {castToCStr(Dest, B), castToCStr(Src, B)}, B, TLI);
+                        const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
+  return emitLibCall(
+      LibFunc_strcat, B.getInt8PtrTy(),
+      {B.getInt8PtrTy(), B.getInt8PtrTy()},
+      {castToCStr(Dest, B), castToCStr(Src, B)}, B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitStrLCpy(Value *Dest, Value *Src, Value *Size, IRBuilderBase &B,
-                         const TargetLibraryInfo *TLI) {
+                         const TargetLibraryInfo *TLI,
+                         const AAMDNodes &AAInfo) {
   return emitLibCall(LibFunc_strlcpy, Size->getType(),
                      {B.getInt8PtrTy(), B.getInt8PtrTy(), Size->getType()},
-                     {castToCStr(Dest, B), castToCStr(Src, B), Size}, B, TLI);
+                     {castToCStr(Dest, B), castToCStr(Src, B), Size}, B, TLI,
+                     false, AAInfo);
 }
 
 Value *llvm::emitStrLCat(Value *Dest, Value *Src, Value *Size, IRBuilderBase &B,
-                         const TargetLibraryInfo *TLI) {
+                         const TargetLibraryInfo *TLI,
+                         const AAMDNodes &AAInfo) {
   return emitLibCall(LibFunc_strlcat, Size->getType(),
                      {B.getInt8PtrTy(), B.getInt8PtrTy(), Size->getType()},
-                     {castToCStr(Dest, B), castToCStr(Src, B), Size}, B, TLI);
+                     {castToCStr(Dest, B), castToCStr(Src, B), Size}, B, TLI,
+                     false, AAInfo);
 }
 
 Value *llvm::emitStrNCat(Value *Dest, Value *Src, Value *Size, IRBuilderBase &B,
-                         const TargetLibraryInfo *TLI) {
+                         const TargetLibraryInfo *TLI,
+                         const AAMDNodes &AAInfo) {
   return emitLibCall(LibFunc_strncat, B.getInt8PtrTy(),
                      {B.getInt8PtrTy(), B.getInt8PtrTy(), Size->getType()},
-                     {castToCStr(Dest, B), castToCStr(Src, B), Size}, B, TLI);
+                     {castToCStr(Dest, B), castToCStr(Src, B), Size}, B, TLI,
+                     false, AAInfo);
 }
 
 Value *llvm::emitVSNPrintf(Value *Dest, Value *Size, Value *Fmt, Value *VAList,
-                           IRBuilderBase &B, const TargetLibraryInfo *TLI) {
+                           IRBuilderBase &B, const TargetLibraryInfo *TLI,
+                           const AAMDNodes &AAInfo) {
   return emitLibCall(
       LibFunc_vsnprintf, B.getInt32Ty(),
       {B.getInt8PtrTy(), Size->getType(), B.getInt8PtrTy(), VAList->getType()},
-      {castToCStr(Dest, B), Size, castToCStr(Fmt, B), VAList}, B, TLI);
+      {castToCStr(Dest, B), Size, castToCStr(Fmt, B), VAList}, B, TLI, false,
+      AAInfo);
 }
 
 Value *llvm::emitVSPrintf(Value *Dest, Value *Fmt, Value *VAList,
-                          IRBuilderBase &B, const TargetLibraryInfo *TLI) {
+                          IRBuilderBase &B, const TargetLibraryInfo *TLI,
+                          const AAMDNodes &AAInfo) {
   return emitLibCall(LibFunc_vsprintf, B.getInt32Ty(),
                      {B.getInt8PtrTy(), B.getInt8PtrTy(), VAList->getType()},
-                     {castToCStr(Dest, B), castToCStr(Fmt, B), VAList}, B, TLI);
+                     {castToCStr(Dest, B), castToCStr(Fmt, B), VAList}, B, TLI,
+                     false, AAInfo);
 }
 
 /// Append a suffix to the function name according to the type of 'Op'.
diff --git a/lib/Transforms/Utils/SimplifyLibCalls.cpp b/lib/Transforms/Utils/SimplifyLibCalls.cpp
index cfcc3454a21..988eff60ee7 100644
--- a/lib/Transforms/Utils/SimplifyLibCalls.cpp
+++ b/lib/Transforms/Utils/SimplifyLibCalls.cpp
@@ -247,14 +247,17 @@ Value *LibCallSimplifier::optimizeStrCat(CallInst *CI, IRBuilderBase &B) {
   if (Len == 0)
     return Dst;
 
-  return emitStrLenMemCpy(Src, Dst, Len, B);
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
+  return emitStrLenMemCpy(Src, Dst, Len, B, AATags);
 }
 
 Value *LibCallSimplifier::emitStrLenMemCpy(Value *Src, Value *Dst, uint64_t Len,
-                                           IRBuilderBase &B) {
+                                           IRBuilderBase &B,
+                                           const AAMDNodes &AATags) {
   // We need to find the end of the destination string.  That's where the
   // memory is to be moved to. We just generate a call to strlen.
-  Value *DstLen = emitStrLen(Dst, B, DL, TLI);
+  Value *DstLen = emitStrLen(Dst, B, DL, TLI, AATags);
   if (!DstLen)
     return nullptr;
 
@@ -265,9 +268,9 @@ Value *LibCallSimplifier::emitStrLenMemCpy(Value *Src, Value *Dst, uint64_t Len,
 
   // We have enough information to now generate the memcpy call to do the
   // concatenation for us.  Make a memcpy to copy the nul byte with align = 1.
-  B.CreateMemCpy(
-      CpyDst, Align(1), Src, Align(1),
-      ConstantInt::get(DL.getIntPtrType(Src->getContext()), Len + 1));
+  B.CreateMemCpy(CpyDst, Align(1), Src, Align(1),
+                 ConstantInt::get(DL.getIntPtrType(Src->getContext()), Len + 1),
+                 false, AATags.TBAA, nullptr, AATags.Scope, AATags.NoAlias);
   return Dst;
 }
 
@@ -309,9 +312,11 @@ Value *LibCallSimplifier::optimizeStrNCat(CallInst *CI, IRBuilderBase &B) {
   if (Len < SrcLen)
     return nullptr;
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   // strncat(x, s, c) -> strcat(x, s)
   // s is constant so the strcat can be optimized further.
-  return emitStrLenMemCpy(Src, Dst, SrcLen, B);
+  return emitStrLenMemCpy(Src, Dst, SrcLen, B, AATags);
 }
 
 Value *LibCallSimplifier::optimizeStrChr(CallInst *CI, IRBuilderBase &B) {
@@ -320,6 +325,9 @@ Value *LibCallSimplifier::optimizeStrChr(CallInst *CI, IRBuilderBase &B) {
   Value *SrcStr = CI->getArgOperand(0);
   annotateNonNullBasedOnAccess(CI, 0);
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
+
   // If the second operand is non-constant, see if we can compute the length
   // of the input string and turn this into memchr.
   ConstantInt *CharC = dyn_cast<ConstantInt>(CI->getArgOperand(1));
@@ -334,7 +342,7 @@ Value *LibCallSimplifier::optimizeStrChr(CallInst *CI, IRBuilderBase &B) {
 
     return emitMemChr(SrcStr, CI->getArgOperand(1), // include nul.
                       ConstantInt::get(DL.getIntPtrType(CI->getContext()), Len),
-                      B, DL, TLI);
+                      B, DL, TLI, AATags);
   }
 
   // Otherwise, the character is a constant, see if the first argument is
@@ -342,7 +350,7 @@ Value *LibCallSimplifier::optimizeStrChr(CallInst *CI, IRBuilderBase &B) {
   StringRef Str;
   if (!getConstantStringInfo(SrcStr, Str)) {
     if (CharC->isZero()) // strchr(p, 0) -> p + strlen(p)
-      if (Value *StrLen = emitStrLen(SrcStr, B, DL, TLI))
+      if (Value *StrLen = emitStrLen(SrcStr, B, DL, TLI, AATags))
         return B.CreateGEP(B.getInt8Ty(), SrcStr, StrLen, "strchr");
     return nullptr;
   }
@@ -371,8 +379,11 @@ Value *LibCallSimplifier::optimizeStrRChr(CallInst *CI, IRBuilderBase &B) {
   StringRef Str;
   if (!getConstantStringInfo(SrcStr, Str)) {
     // strrchr(s, 0) -> strchr(s, 0)
-    if (CharC->isZero())
-      return emitStrChr(SrcStr, '\0', B, TLI);
+    if (CharC->isZero()) {
+      AAMDNodes AATags;
+      CI->getAAMetadata(AATags);
+      return emitStrChr(SrcStr, '\0', B, TLI, AATags);
+    }
     return nullptr;
   }
 
@@ -400,13 +411,19 @@ Value *LibCallSimplifier::optimizeStrCmp(CallInst *CI, IRBuilderBase &B) {
   if (HasStr1 && HasStr2)
     return ConstantInt::get(CI->getType(), Str1.compare(Str2));
 
-  if (HasStr1 && Str1.empty()) // strcmp("", x) -> -*x
-    return B.CreateNeg(B.CreateZExt(
-        B.CreateLoad(B.getInt8Ty(), Str2P, "strcmpload"), CI->getType()));
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
+  if (HasStr1 && Str1.empty()) { // strcmp("", x) -> -*x
+    auto load = B.CreateLoad(B.getInt8Ty(), Str2P, "strcmpload");
+    load->setAAMetadata(AATags);
+    return B.CreateNeg(B.CreateZExt(load, CI->getType()));
+  }
 
-  if (HasStr2 && Str2.empty()) // strcmp(x,"") -> *x
-    return B.CreateZExt(B.CreateLoad(B.getInt8Ty(), Str1P, "strcmpload"),
-                        CI->getType());
+  if (HasStr2 && Str2.empty()) { // strcmp(x,"") -> *x
+    auto load = B.CreateLoad(B.getInt8Ty(), Str1P, "strcmpload");
+    load->setAAMetadata(AATags);
+    return B.CreateZExt(load, CI->getType());
+  }
 
   // strcmp(P, "x") -> memcmp(P, "x", 2)
   uint64_t Len1 = GetStringLength(Str1P);
@@ -420,7 +437,7 @@ Value *LibCallSimplifier::optimizeStrCmp(CallInst *CI, IRBuilderBase &B) {
     return emitMemCmp(Str1P, Str2P,
                       ConstantInt::get(DL.getIntPtrType(CI->getContext()),
                                        std::min(Len1, Len2)),
-                      B, DL, TLI);
+                      B, DL, TLI, AATags);
   }
 
   // strcmp to memcmp
@@ -429,13 +446,13 @@ Value *LibCallSimplifier::optimizeStrCmp(CallInst *CI, IRBuilderBase &B) {
       return emitMemCmp(
           Str1P, Str2P,
           ConstantInt::get(DL.getIntPtrType(CI->getContext()), Len2), B, DL,
-          TLI);
+          TLI, AATags);
   } else if (HasStr1 && !HasStr2) {
     if (canTransformToMemCmp(CI, Str2P, Len1, DL))
       return emitMemCmp(
           Str1P, Str2P,
           ConstantInt::get(DL.getIntPtrType(CI->getContext()), Len1), B, DL,
-          TLI);
+          TLI, AATags);
   }
 
   annotateNonNullBasedOnAccess(CI, {0, 1});
@@ -461,8 +478,10 @@ Value *LibCallSimplifier::optimizeStrNCmp(CallInst *CI, IRBuilderBase &B) {
   if (Length == 0) // strncmp(x,y,0)   -> 0
     return ConstantInt::get(CI->getType(), 0);
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   if (Length == 1) // strncmp(x,y,1) -> memcmp(x,y,1)
-    return emitMemCmp(Str1P, Str2P, Size, B, DL, TLI);
+    return emitMemCmp(Str1P, Str2P, Size, B, DL, TLI, AATags);
 
   StringRef Str1, Str2;
   bool HasStr1 = getConstantStringInfo(Str1P, Str1);
@@ -475,13 +494,17 @@ Value *LibCallSimplifier::optimizeStrNCmp(CallInst *CI, IRBuilderBase &B) {
     return ConstantInt::get(CI->getType(), SubStr1.compare(SubStr2));
   }
 
-  if (HasStr1 && Str1.empty()) // strncmp("", x, n) -> -*x
-    return B.CreateNeg(B.CreateZExt(
-        B.CreateLoad(B.getInt8Ty(), Str2P, "strcmpload"), CI->getType()));
+  if (HasStr1 && Str1.empty()) { // strncmp("", x, n) -> -*x
+    auto load = B.CreateLoad(B.getInt8Ty(), Str2P, "strcmpload");
+    load->setAAMetadata(AATags);
+    return B.CreateNeg(B.CreateZExt(load, CI->getType()));
+  }
 
-  if (HasStr2 && Str2.empty()) // strncmp(x, "", n) -> *x
-    return B.CreateZExt(B.CreateLoad(B.getInt8Ty(), Str1P, "strcmpload"),
-                        CI->getType());
+  if (HasStr2 && Str2.empty()) { // strncmp(x, "", n) -> *x
+    auto load = B.CreateLoad(B.getInt8Ty(), Str1P, "strcmpload");
+    load->setAAMetadata(AATags);
+    return B.CreateZExt(load, CI->getType());
+  }
 
   uint64_t Len1 = GetStringLength(Str1P);
   if (Len1)
@@ -497,14 +520,14 @@ Value *LibCallSimplifier::optimizeStrNCmp(CallInst *CI, IRBuilderBase &B) {
       return emitMemCmp(
           Str1P, Str2P,
           ConstantInt::get(DL.getIntPtrType(CI->getContext()), Len2), B, DL,
-          TLI);
+          TLI, AATags);
   } else if (HasStr1 && !HasStr2) {
     Len1 = std::min(Len1, Length);
     if (canTransformToMemCmp(CI, Str2P, Len1, DL))
       return emitMemCmp(
           Str1P, Str2P,
           ConstantInt::get(DL.getIntPtrType(CI->getContext()), Len1), B, DL,
-          TLI);
+          TLI, AATags);
   }
 
   return nullptr;
@@ -516,8 +539,11 @@ Value *LibCallSimplifier::optimizeStrNDup(CallInst *CI, IRBuilderBase &B) {
   uint64_t SrcLen = GetStringLength(Src);
   if (SrcLen && Size) {
     annotateDereferenceableBytes(CI, 0, SrcLen);
-    if (SrcLen <= Size->getZExtValue() + 1)
-      return emitStrDup(Src, B, TLI);
+    if (SrcLen <= Size->getZExtValue() + 1) {
+      AAMDNodes AATags;
+      CI->getAAMetadata(AATags);
+      return emitStrDup(Src, B, TLI, AATags);
+    }
   }
 
   return nullptr;
@@ -536,11 +562,14 @@ Value *LibCallSimplifier::optimizeStrCpy(CallInst *CI, IRBuilderBase &B) {
   else
     return nullptr;
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   // We have enough information to now generate the memcpy call to do the
   // copy for us.  Make a memcpy to copy the nul byte with align = 1.
   CallInst *NewCI =
       B.CreateMemCpy(Dst, Align(1), Src, Align(1),
-                     ConstantInt::get(DL.getIntPtrType(CI->getContext()), Len));
+                     ConstantInt::get(DL.getIntPtrType(CI->getContext()), Len),
+                     false, AATags.TBAA, nullptr, AATags.Scope, AATags.NoAlias);
   NewCI->setAttributes(CI->getAttributes());
   return Dst;
 }
@@ -548,8 +577,10 @@ Value *LibCallSimplifier::optimizeStrCpy(CallInst *CI, IRBuilderBase &B) {
 Value *LibCallSimplifier::optimizeStpCpy(CallInst *CI, IRBuilderBase &B) {
   Function *Callee = CI->getCalledFunction();
   Value *Dst = CI->getArgOperand(0), *Src = CI->getArgOperand(1);
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   if (Dst == Src) { // stpcpy(x,x)  -> x+strlen(x)
-    Value *StrLen = emitStrLen(Src, B, DL, TLI);
+    Value *StrLen = emitStrLen(Src, B, DL, TLI, AATags);
     return StrLen ? B.CreateInBoundsGEP(B.getInt8Ty(), Dst, StrLen) : nullptr;
   }
 
@@ -567,7 +598,9 @@ Value *LibCallSimplifier::optimizeStpCpy(CallInst *CI, IRBuilderBase &B) {
 
   // We have enough information to now generate the memcpy call to do the
   // copy for us.  Make a memcpy to copy the nul byte with align = 1.
-  CallInst *NewCI = B.CreateMemCpy(Dst, Align(1), Src, Align(1), LenV);
+  CallInst *NewCI =
+      B.CreateMemCpy(Dst, Align(1), Src, Align(1), LenV, false, AATags.TBAA,
+                     nullptr, AATags.Scope, AATags.NoAlias);
   NewCI->setAttributes(CI->getAttributes());
   return DstEnd;
 }
@@ -600,9 +633,13 @@ Value *LibCallSimplifier::optimizeStrNCpy(CallInst *CI, IRBuilderBase &B) {
     return nullptr;
   }
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   if (SrcLen == 0) {
     // strncpy(x, "", y) -> memset(align 1 x, '\0', y)
-    CallInst *NewCI = B.CreateMemSet(Dst, B.getInt8('\0'), Size, Align(1));
+    CallInst *NewCI =
+        B.CreateMemSet(Dst, B.getInt8('\0'), Size, Align(1), false, AATags.TBAA,
+                       AATags.Scope, AATags.NoAlias);
     AttrBuilder ArgAttrs(CI->getAttributes().getParamAttributes(0));
     NewCI->setAttributes(NewCI->getAttributes().addParamAttributes(
         CI->getContext(), 0, ArgAttrs));
@@ -615,8 +652,9 @@ Value *LibCallSimplifier::optimizeStrNCpy(CallInst *CI, IRBuilderBase &B) {
 
   Type *PT = Callee->getFunctionType()->getParamType(0);
   // strncpy(x, s, c) -> memcpy(align 1 x, align 1 s, c) [s and c are constant]
-  CallInst *NewCI = B.CreateMemCpy(Dst, Align(1), Src, Align(1),
-                                   ConstantInt::get(DL.getIntPtrType(PT), Len));
+  CallInst *NewCI = B.CreateMemCpy(
+      Dst, Align(1), Src, Align(1), ConstantInt::get(DL.getIntPtrType(PT), Len),
+      false, AATags.TBAA, nullptr, AATags.Scope, AATags.NoAlias);
   NewCI->setAttributes(CI->getAttributes());
   return Dst;
 }
@@ -705,9 +743,13 @@ Value *LibCallSimplifier::optimizeStringLength(CallInst *CI, IRBuilderBase &B,
 
   // strlen(x) != 0 --> *x != 0
   // strlen(x) == 0 --> *x == 0
-  if (isOnlyUsedInZeroEqualityComparison(CI))
-    return B.CreateZExt(B.CreateLoad(B.getIntNTy(CharSize), Src, "strlenfirst"),
-                        CI->getType());
+  if (isOnlyUsedInZeroEqualityComparison(CI)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
+    auto load = B.CreateLoad(B.getIntNTy(CharSize), Src, "strlenfirst");
+    load->setAAMetadata(AATags);
+    return B.CreateZExt(load, CI->getType());
+  }
 
   return nullptr;
 }
@@ -750,8 +792,11 @@ Value *LibCallSimplifier::optimizeStrPBrk(CallInst *CI, IRBuilderBase &B) {
   }
 
   // strpbrk(s, "a") -> strchr(s, 'a')
-  if (HasS2 && S2.size() == 1)
-    return emitStrChr(CI->getArgOperand(0), S2[0], B, TLI);
+  if (HasS2 && S2.size() == 1) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
+    return emitStrChr(CI->getArgOperand(0), S2[0], B, TLI, AATags);
+  }
 
   return nullptr;
 }
@@ -806,8 +851,11 @@ Value *LibCallSimplifier::optimizeStrCSpn(CallInst *CI, IRBuilderBase &B) {
   }
 
   // strcspn(s, "") -> strlen(s)
-  if (HasS2 && S2.empty())
-    return emitStrLen(CI->getArgOperand(0), B, DL, TLI);
+  if (HasS2 && S2.empty()) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
+    return emitStrLen(CI->getArgOperand(0), B, DL, TLI, AATags);
+  }
 
   return nullptr;
 }
@@ -817,13 +865,15 @@ Value *LibCallSimplifier::optimizeStrStr(CallInst *CI, IRBuilderBase &B) {
   if (CI->getArgOperand(0) == CI->getArgOperand(1))
     return B.CreateBitCast(CI->getArgOperand(0), CI->getType());
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   // fold strstr(a, b) == a -> strncmp(a, b, strlen(b)) == 0
   if (isOnlyUsedInEqualityComparison(CI, CI->getArgOperand(0))) {
-    Value *StrLen = emitStrLen(CI->getArgOperand(1), B, DL, TLI);
+    Value *StrLen = emitStrLen(CI->getArgOperand(1), B, DL, TLI, AATags);
     if (!StrLen)
       return nullptr;
     Value *StrNCmp = emitStrNCmp(CI->getArgOperand(0), CI->getArgOperand(1),
-                                 StrLen, B, DL, TLI);
+                                 StrLen, B, DL, TLI, AATags);
     if (!StrNCmp)
       return nullptr;
     for (auto UI = CI->user_begin(), UE = CI->user_end(); UI != UE;) {
@@ -861,7 +911,8 @@ Value *LibCallSimplifier::optimizeStrStr(CallInst *CI, IRBuilderBase &B) {
 
   // fold strstr(x, "y") -> strchr(x, 'y').
   if (HasStr2 && ToFindStr.size() == 1) {
-    Value *StrChr = emitStrChr(CI->getArgOperand(0), ToFindStr[0], B, TLI);
+    Value *StrChr =
+        emitStrChr(CI->getArgOperand(0), ToFindStr[0], B, TLI, AATags);
     return StrChr ? B.CreateBitCast(StrChr, CI->getType()) : nullptr;
   }
 
@@ -969,14 +1020,17 @@ static Value *optimizeMemCmpConstantSize(CallInst *CI, Value *LHS, Value *RHS,
   if (Len == 0) // memcmp(s1,s2,0) -> 0
     return Constant::getNullValue(CI->getType());
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
+
   // memcmp(S1,S2,1) -> *(unsigned char*)LHS - *(unsigned char*)RHS
   if (Len == 1) {
-    Value *LHSV =
-        B.CreateZExt(B.CreateLoad(B.getInt8Ty(), castToCStr(LHS, B), "lhsc"),
-                     CI->getType(), "lhsv");
-    Value *RHSV =
-        B.CreateZExt(B.CreateLoad(B.getInt8Ty(), castToCStr(RHS, B), "rhsc"),
-                     CI->getType(), "rhsv");
+    auto load1 = B.CreateLoad(B.getInt8Ty(), castToCStr(LHS, B), "lhsc");
+    load1->setAAMetadata(AATags);
+    Value *LHSV = B.CreateZExt(load1, CI->getType(), "lhsv");
+    auto load2 = B.CreateLoad(B.getInt8Ty(), castToCStr(RHS, B), "rhsc");
+    load2->setAAMetadata(AATags);
+    Value *RHSV = B.CreateZExt(load2, CI->getType(), "rhsv");
     return B.CreateSub(LHSV, RHSV, "chardiff");
   }
 
@@ -1007,11 +1061,13 @@ static Value *optimizeMemCmpConstantSize(CallInst *CI, Value *LHS, Value *RHS,
         Type *LHSPtrTy =
             IntType->getPointerTo(LHS->getType()->getPointerAddressSpace());
         LHSV = B.CreateLoad(IntType, B.CreateBitCast(LHS, LHSPtrTy), "lhsv");
+        cast<LoadInst>(LHSV)->setAAMetadata(AATags);
       }
       if (!RHSV) {
         Type *RHSPtrTy =
             IntType->getPointerTo(RHS->getType()->getPointerAddressSpace());
         RHSV = B.CreateLoad(IntType, B.CreateBitCast(RHS, RHSPtrTy), "rhsv");
+        cast<LoadInst>(RHSV)->setAAMetadata(AATags);
       }
       return B.CreateZExt(B.CreateICmpNE(LHSV, RHSV), CI->getType(), "memcmp");
     }
@@ -1075,7 +1131,9 @@ Value *LibCallSimplifier::optimizeMemCmp(CallInst *CI, IRBuilderBase &B) {
     Value *LHS = CI->getArgOperand(0);
     Value *RHS = CI->getArgOperand(1);
     Value *Size = CI->getArgOperand(2);
-    return emitBCmp(LHS, RHS, Size, B, DL, TLI);
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
+    return emitBCmp(LHS, RHS, Size, B, DL, TLI, AATags);
   }
 
   return nullptr;
@@ -1091,9 +1149,12 @@ Value *LibCallSimplifier::optimizeMemCpy(CallInst *CI, IRBuilderBase &B) {
   if (isa<IntrinsicInst>(CI))
     return nullptr;
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   // memcpy(x, y, n) -> llvm.memcpy(align 1 x, align 1 y, n)
-  CallInst *NewCI = B.CreateMemCpy(CI->getArgOperand(0), Align(1),
-                                   CI->getArgOperand(1), Align(1), Size);
+  CallInst *NewCI = B.CreateMemCpy(
+      CI->getArgOperand(0), Align(1), CI->getArgOperand(1), Align(1), Size,
+      false, AATags.TBAA, AATags.TBAAStruct, AATags.Scope, AATags.NoAlias);
   NewCI->setAttributes(CI->getAttributes());
   return CI->getArgOperand(0);
 }
@@ -1118,11 +1179,15 @@ Value *LibCallSimplifier::optimizeMemCCpy(CallInst *CI, IRBuilderBase &B) {
     return nullptr;
   }
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
+
   // Wrap arg 'c' of type int to char
   size_t Pos = SrcStr.find(StopChar->getSExtValue() & 0xFF);
   if (Pos == StringRef::npos) {
     if (N->getZExtValue() <= SrcStr.size()) {
-      B.CreateMemCpy(Dst, Align(1), Src, Align(1), CI->getArgOperand(3));
+      B.CreateMemCpy(Dst, Align(1), Src, Align(1), CI->getArgOperand(3), false,
+                     AATags.TBAA, nullptr, AATags.Scope, AATags.NoAlias);
       return Constant::getNullValue(CI->getType());
     }
     return nullptr;
@@ -1131,7 +1196,8 @@ Value *LibCallSimplifier::optimizeMemCCpy(CallInst *CI, IRBuilderBase &B) {
   Value *NewN =
       ConstantInt::get(N->getType(), std::min(uint64_t(Pos + 1), N->getZExtValue()));
   // memccpy -> llvm.memcpy
-  B.CreateMemCpy(Dst, Align(1), Src, Align(1), NewN);
+  B.CreateMemCpy(Dst, Align(1), Src, Align(1), NewN, false, AATags.TBAA,
+                 nullptr, AATags.Scope, AATags.NoAlias);
   return Pos + 1 <= N->getZExtValue()
              ? B.CreateInBoundsGEP(B.getInt8Ty(), Dst, NewN)
              : Constant::getNullValue(CI->getType());
@@ -1140,9 +1206,12 @@ Value *LibCallSimplifier::optimizeMemCCpy(CallInst *CI, IRBuilderBase &B) {
 Value *LibCallSimplifier::optimizeMemPCpy(CallInst *CI, IRBuilderBase &B) {
   Value *Dst = CI->getArgOperand(0);
   Value *N = CI->getArgOperand(2);
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   // mempcpy(x, y, n) -> llvm.memcpy(align 1 x, align 1 y, n), x + n
   CallInst *NewCI =
-      B.CreateMemCpy(Dst, Align(1), CI->getArgOperand(1), Align(1), N);
+      B.CreateMemCpy(Dst, Align(1), CI->getArgOperand(1), Align(1), N, false,
+                     AATags.TBAA, nullptr, AATags.Scope, AATags.NoAlias);
   NewCI->setAttributes(CI->getAttributes());
   return B.CreateInBoundsGEP(B.getInt8Ty(), Dst, N);
 }
@@ -1153,9 +1222,12 @@ Value *LibCallSimplifier::optimizeMemMove(CallInst *CI, IRBuilderBase &B) {
   if (isa<IntrinsicInst>(CI))
     return nullptr;
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   // memmove(x, y, n) -> llvm.memmove(align 1 x, align 1 y, n)
   CallInst *NewCI = B.CreateMemMove(CI->getArgOperand(0), Align(1),
-                                    CI->getArgOperand(1), Align(1), Size);
+                                    CI->getArgOperand(1), Align(1), Size, false,
+                                    AATags.TBAA, AATags.Scope, AATags.NoAlias);
   NewCI->setAttributes(CI->getAttributes());
   return CI->getArgOperand(0);
 }
@@ -1213,9 +1285,13 @@ Value *LibCallSimplifier::optimizeMemSet(CallInst *CI, IRBuilderBase &B) {
   if (auto *Calloc = foldMallocMemset(CI, B))
     return Calloc;
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   // memset(p, v, n) -> llvm.memset(align 1 p, v, n)
   Value *Val = B.CreateIntCast(CI->getArgOperand(1), B.getInt8Ty(), false);
-  CallInst *NewCI = B.CreateMemSet(CI->getArgOperand(0), Val, Size, Align(1));
+  CallInst *NewCI =
+      B.CreateMemSet(CI->getArgOperand(0), Val, Size, Align(1), false,
+                     AATags.TBAA, AATags.Scope, AATags.NoAlias);
   NewCI->setAttributes(CI->getAttributes());
   return CI->getArgOperand(0);
 }
@@ -2446,6 +2522,8 @@ Value *LibCallSimplifier::optimizeSPrintFString(CallInst *CI,
   if (!getConstantStringInfo(CI->getArgOperand(1), FormatStr))
     return nullptr;
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   // If we just have a format string (nothing else crazy) transform it.
   if (CI->getNumArgOperands() == 2) {
     // Make sure there's no % in the constant array.  We could try to handle
@@ -2457,7 +2535,8 @@ Value *LibCallSimplifier::optimizeSPrintFString(CallInst *CI,
     B.CreateMemCpy(
         CI->getArgOperand(0), Align(1), CI->getArgOperand(1), Align(1),
         ConstantInt::get(DL.getIntPtrType(CI->getContext()),
-                         FormatStr.size() + 1)); // Copy the null byte.
+                         FormatStr.size() + 1), // Copy the null byte.
+        false, AATags.TBAA, nullptr, AATags.Scope, AATags.NoAlias);
     return ConstantInt::get(CI->getType(), FormatStr.size());
   }
 
@@ -2474,9 +2553,9 @@ Value *LibCallSimplifier::optimizeSPrintFString(CallInst *CI,
       return nullptr;
     Value *V = B.CreateTrunc(CI->getArgOperand(2), B.getInt8Ty(), "char");
     Value *Ptr = castToCStr(CI->getArgOperand(0), B);
-    B.CreateStore(V, Ptr);
+    B.CreateStore(V, Ptr)->setAAMetadata(AATags);
     Ptr = B.CreateGEP(B.getInt8Ty(), Ptr, B.getInt32(1), "nul");
-    B.CreateStore(B.getInt8(0), Ptr);
+    B.CreateStore(B.getInt8(0), Ptr)->setAAMetadata(AATags);
 
     return ConstantInt::get(CI->getType(), 1);
   }
@@ -2487,13 +2566,14 @@ Value *LibCallSimplifier::optimizeSPrintFString(CallInst *CI,
     if (!CI->getArgOperand(2)->getType()->isPointerTy())
       return nullptr;
 
-    Value *Len = emitStrLen(CI->getArgOperand(2), B, DL, TLI);
+    Value *Len = emitStrLen(CI->getArgOperand(2), B, DL, TLI, AATags);
     if (!Len)
       return nullptr;
     Value *IncLen =
         B.CreateAdd(Len, ConstantInt::get(Len->getType(), 1), "leninc");
     B.CreateMemCpy(CI->getArgOperand(0), Align(1), CI->getArgOperand(2),
-                   Align(1), IncLen);
+                   Align(1), IncLen, false, AATags.TBAA, nullptr, AATags.Scope,
+                   AATags.NoAlias);
 
     // The sprintf result is the unincremented number of bytes in the string.
     return B.CreateIntCast(Len, CI->getType(), false);
@@ -2550,6 +2630,8 @@ Value *LibCallSimplifier::optimizeSnPrintFString(CallInst *CI,
   if (!getConstantStringInfo(CI->getArgOperand(2), FormatStr))
     return nullptr;
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   // If we just have a format string (nothing else crazy) transform it.
   if (CI->getNumArgOperands() == 3) {
     // Make sure there's no % in the constant array.  We could try to handle
@@ -2564,10 +2646,12 @@ Value *LibCallSimplifier::optimizeSnPrintFString(CallInst *CI,
 
     // snprintf(dst, size, fmt) -> llvm.memcpy(align 1 dst, align 1 fmt,
     // strlen(fmt)+1)
-    B.CreateMemCpy(
-        CI->getArgOperand(0), Align(1), CI->getArgOperand(2), Align(1),
-        ConstantInt::get(DL.getIntPtrType(CI->getContext()),
-                         FormatStr.size() + 1)); // Copy the null byte.
+    B.CreateMemCpy(CI->getArgOperand(0), Align(1), CI->getArgOperand(2),
+                   Align(1),
+                   ConstantInt::get(DL.getIntPtrType(CI->getContext()),
+                                    FormatStr.size() + 1), // Copy the null byte.
+                   false, AATags.TBAA, nullptr,
+                   AATags.Scope, AATags.NoAlias);
     return ConstantInt::get(CI->getType(), FormatStr.size());
   }
 
@@ -2588,9 +2672,9 @@ Value *LibCallSimplifier::optimizeSnPrintFString(CallInst *CI,
         return nullptr;
       Value *V = B.CreateTrunc(CI->getArgOperand(3), B.getInt8Ty(), "char");
       Value *Ptr = castToCStr(CI->getArgOperand(0), B);
-      B.CreateStore(V, Ptr);
+      B.CreateStore(V, Ptr)->setAAMetadata(AATags);
       Ptr = B.CreateGEP(B.getInt8Ty(), Ptr, B.getInt32(1), "nul");
-      B.CreateStore(B.getInt8(0), Ptr);
+      B.CreateStore(B.getInt8(0), Ptr)->setAAMetadata(AATags);
 
       return ConstantInt::get(CI->getType(), 1);
     }
@@ -2607,7 +2691,8 @@ Value *LibCallSimplifier::optimizeSnPrintFString(CallInst *CI,
         return nullptr;
 
       B.CreateMemCpy(CI->getArgOperand(0), Align(1), CI->getArgOperand(3),
-                     Align(1), ConstantInt::get(CI->getType(), Str.size() + 1));
+                     Align(1), ConstantInt::get(CI->getType(), Str.size() + 1),
+                     false, AATags.TBAA, nullptr, AATags.Scope, AATags.NoAlias);
 
       // The snprintf result is the unincremented number of bytes in the string.
       return ConstantInt::get(CI->getType(), Str.size());
@@ -2780,8 +2865,11 @@ Value *LibCallSimplifier::optimizePuts(CallInst *CI, IRBuilderBase &B) {
 
 Value *LibCallSimplifier::optimizeBCopy(CallInst *CI, IRBuilderBase &B) {
   // bcopy(src, dst, n) -> llvm.memmove(dst, src, n)
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   return B.CreateMemMove(CI->getArgOperand(1), Align(1), CI->getArgOperand(0),
-                         Align(1), CI->getArgOperand(2));
+                         Align(1), CI->getArgOperand(2), false, AATags.TBAA,
+                         AATags.Scope, AATags.NoAlias);
 }
 
 bool LibCallSimplifier::hasFloatVersion(StringRef FuncName) {
@@ -3215,9 +3303,12 @@ FortifiedLibCallSimplifier::isFortifiedCallFoldable(CallInst *CI,
 Value *FortifiedLibCallSimplifier::optimizeMemCpyChk(CallInst *CI,
                                                      IRBuilderBase &B) {
   if (isFortifiedCallFoldable(CI, 3, 2)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     CallInst *NewCI =
         B.CreateMemCpy(CI->getArgOperand(0), Align(1), CI->getArgOperand(1),
-                       Align(1), CI->getArgOperand(2));
+                       Align(1), CI->getArgOperand(2), false, AATags.TBAA,
+                       AATags.TBAAStruct, AATags.Scope, AATags.NoAlias);
     NewCI->setAttributes(CI->getAttributes());
     return CI->getArgOperand(0);
   }
@@ -3227,9 +3318,12 @@ Value *FortifiedLibCallSimplifier::optimizeMemCpyChk(CallInst *CI,
 Value *FortifiedLibCallSimplifier::optimizeMemMoveChk(CallInst *CI,
                                                       IRBuilderBase &B) {
   if (isFortifiedCallFoldable(CI, 3, 2)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     CallInst *NewCI =
-        B.CreateMemMove(CI->getArgOperand(0), Align(1), CI->getArgOperand(1),
-                        Align(1), CI->getArgOperand(2));
+        B.CreateMemMove(
+            CI->getArgOperand(0), Align(1), CI->getArgOperand(1), Align(1),
+            CI->getArgOperand(2), false, AATags.TBAA, AATags.Scope, AATags.NoAlias);
     NewCI->setAttributes(CI->getAttributes());
     return CI->getArgOperand(0);
   }
@@ -3242,8 +3336,11 @@ Value *FortifiedLibCallSimplifier::optimizeMemSetChk(CallInst *CI,
 
   if (isFortifiedCallFoldable(CI, 3, 2)) {
     Value *Val = B.CreateIntCast(CI->getArgOperand(1), B.getInt8Ty(), false);
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     CallInst *NewCI = B.CreateMemSet(CI->getArgOperand(0), Val,
-                                     CI->getArgOperand(2), Align(1));
+                                     CI->getArgOperand(2), Align(1), false,
+                                     AATags.TBAA, AATags.Scope, AATags.NoAlias);
     NewCI->setAttributes(CI->getAttributes());
     return CI->getArgOperand(0);
   }
@@ -3257,9 +3354,11 @@ Value *FortifiedLibCallSimplifier::optimizeStrpCpyChk(CallInst *CI,
   Value *Dst = CI->getArgOperand(0), *Src = CI->getArgOperand(1),
         *ObjSize = CI->getArgOperand(2);
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   // __stpcpy_chk(x,x,...)  -> x+strlen(x)
   if (Func == LibFunc_stpcpy_chk && !OnlyLowerUnknownSize && Dst == Src) {
-    Value *StrLen = emitStrLen(Src, B, DL, TLI);
+    Value *StrLen = emitStrLen(Src, B, DL, TLI, AATags);
     return StrLen ? B.CreateInBoundsGEP(B.getInt8Ty(), Dst, StrLen) : nullptr;
   }
 
@@ -3270,9 +3369,9 @@ Value *FortifiedLibCallSimplifier::optimizeStrpCpyChk(CallInst *CI,
   // string lengths for varying.
   if (isFortifiedCallFoldable(CI, 2, None, 1)) {
     if (Func == LibFunc_strcpy_chk)
-      return emitStrCpy(Dst, Src, B, TLI);
+      return emitStrCpy(Dst, Src, B, TLI, AATags);
     else
-      return emitStpCpy(Dst, Src, B, TLI);
+      return emitStpCpy(Dst, Src, B, TLI, AATags);
   }
 
   if (OnlyLowerUnknownSize)
@@ -3287,7 +3386,7 @@ Value *FortifiedLibCallSimplifier::optimizeStrpCpyChk(CallInst *CI,
 
   Type *SizeTTy = DL.getIntPtrType(CI->getContext());
   Value *LenV = ConstantInt::get(SizeTTy, Len);
-  Value *Ret = emitMemCpyChk(Dst, Src, LenV, ObjSize, B, DL, TLI);
+  Value *Ret = emitMemCpyChk(Dst, Src, LenV, ObjSize, B, DL, TLI, AATags);
   // If the function was an __stpcpy_chk, and we were able to fold it into
   // a __memcpy_chk, we still need to return the correct end pointer.
   if (Ret && Func == LibFunc_stpcpy_chk)
@@ -3297,9 +3396,12 @@ Value *FortifiedLibCallSimplifier::optimizeStrpCpyChk(CallInst *CI,
 
 Value *FortifiedLibCallSimplifier::optimizeStrLenChk(CallInst *CI,
                                                      IRBuilderBase &B) {
-  if (isFortifiedCallFoldable(CI, 1, None, 0))
+  if (isFortifiedCallFoldable(CI, 1, None, 0)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     return emitStrLen(CI->getArgOperand(0), B, CI->getModule()->getDataLayout(),
-                      TLI);
+                      TLI, AATags);
+  }
   return nullptr;
 }
 
@@ -3307,12 +3409,14 @@ Value *FortifiedLibCallSimplifier::optimizeStrpNCpyChk(CallInst *CI,
                                                        IRBuilderBase &B,
                                                        LibFunc Func) {
   if (isFortifiedCallFoldable(CI, 3, 2)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     if (Func == LibFunc_strncpy_chk)
       return emitStrNCpy(CI->getArgOperand(0), CI->getArgOperand(1),
-                               CI->getArgOperand(2), B, TLI);
+                         CI->getArgOperand(2), B, TLI, AATags);
     else
       return emitStpNCpy(CI->getArgOperand(0), CI->getArgOperand(1),
-                         CI->getArgOperand(2), B, TLI);
+                         CI->getArgOperand(2), B, TLI, AATags);
   }
 
   return nullptr;
@@ -3320,9 +3424,13 @@ Value *FortifiedLibCallSimplifier::optimizeStrpNCpyChk(CallInst *CI,
 
 Value *FortifiedLibCallSimplifier::optimizeMemCCpyChk(CallInst *CI,
                                                       IRBuilderBase &B) {
-  if (isFortifiedCallFoldable(CI, 4, 3))
+  if (isFortifiedCallFoldable(CI, 4, 3)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     return emitMemCCpy(CI->getArgOperand(0), CI->getArgOperand(1),
-                       CI->getArgOperand(2), CI->getArgOperand(3), B, TLI);
+                       CI->getArgOperand(2), CI->getArgOperand(3), B, TLI,
+                       AATags);
+  }
 
   return nullptr;
 }
@@ -3331,8 +3439,10 @@ Value *FortifiedLibCallSimplifier::optimizeSNPrintfChk(CallInst *CI,
                                                        IRBuilderBase &B) {
   if (isFortifiedCallFoldable(CI, 3, 1, None, 2)) {
     SmallVector<Value *, 8> VariadicArgs(CI->arg_begin() + 5, CI->arg_end());
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     return emitSNPrintf(CI->getArgOperand(0), CI->getArgOperand(1),
-                        CI->getArgOperand(4), VariadicArgs, B, TLI);
+                        CI->getArgOperand(4), VariadicArgs, B, TLI, AATags);
   }
 
   return nullptr;
@@ -3342,8 +3452,10 @@ Value *FortifiedLibCallSimplifier::optimizeSPrintfChk(CallInst *CI,
                                                       IRBuilderBase &B) {
   if (isFortifiedCallFoldable(CI, 2, None, None, 1)) {
     SmallVector<Value *, 8> VariadicArgs(CI->arg_begin() + 4, CI->arg_end());
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     return emitSPrintf(CI->getArgOperand(0), CI->getArgOperand(3), VariadicArgs,
-                       B, TLI);
+                       B, TLI, AATags);
   }
 
   return nullptr;
@@ -3351,53 +3463,73 @@ Value *FortifiedLibCallSimplifier::optimizeSPrintfChk(CallInst *CI,
 
 Value *FortifiedLibCallSimplifier::optimizeStrCatChk(CallInst *CI,
                                                      IRBuilderBase &B) {
-  if (isFortifiedCallFoldable(CI, 2))
-    return emitStrCat(CI->getArgOperand(0), CI->getArgOperand(1), B, TLI);
+  if (isFortifiedCallFoldable(CI, 2)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
+    return emitStrCat(CI->getArgOperand(0), CI->getArgOperand(1), B, TLI,
+                      AATags);
+  }
 
   return nullptr;
 }
 
 Value *FortifiedLibCallSimplifier::optimizeStrLCat(CallInst *CI,
                                                    IRBuilderBase &B) {
-  if (isFortifiedCallFoldable(CI, 3))
+  if (isFortifiedCallFoldable(CI, 3)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     return emitStrLCat(CI->getArgOperand(0), CI->getArgOperand(1),
-                       CI->getArgOperand(2), B, TLI);
+                       CI->getArgOperand(2), B, TLI, AATags);
+  }
 
   return nullptr;
 }
 
 Value *FortifiedLibCallSimplifier::optimizeStrNCatChk(CallInst *CI,
                                                       IRBuilderBase &B) {
-  if (isFortifiedCallFoldable(CI, 3))
+  if (isFortifiedCallFoldable(CI, 3)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     return emitStrNCat(CI->getArgOperand(0), CI->getArgOperand(1),
-                       CI->getArgOperand(2), B, TLI);
+                       CI->getArgOperand(2), B, TLI, AATags);
+  }
 
   return nullptr;
 }
 
 Value *FortifiedLibCallSimplifier::optimizeStrLCpyChk(CallInst *CI,
                                                       IRBuilderBase &B) {
-  if (isFortifiedCallFoldable(CI, 3))
+  if (isFortifiedCallFoldable(CI, 3)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     return emitStrLCpy(CI->getArgOperand(0), CI->getArgOperand(1),
-                       CI->getArgOperand(2), B, TLI);
+                       CI->getArgOperand(2), B, TLI, AATags);
+  }
 
   return nullptr;
 }
 
 Value *FortifiedLibCallSimplifier::optimizeVSNPrintfChk(CallInst *CI,
                                                         IRBuilderBase &B) {
-  if (isFortifiedCallFoldable(CI, 3, 1, None, 2))
+  if (isFortifiedCallFoldable(CI, 3, 1, None, 2)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     return emitVSNPrintf(CI->getArgOperand(0), CI->getArgOperand(1),
-                         CI->getArgOperand(4), CI->getArgOperand(5), B, TLI);
+                         CI->getArgOperand(4), CI->getArgOperand(5), B, TLI,
+                         AATags);
+  }
 
   return nullptr;
 }
 
 Value *FortifiedLibCallSimplifier::optimizeVSPrintfChk(CallInst *CI,
                                                        IRBuilderBase &B) {
-  if (isFortifiedCallFoldable(CI, 2, None, None, 1))
+  if (isFortifiedCallFoldable(CI, 2, None, None, 1)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     return emitVSPrintf(CI->getArgOperand(0), CI->getArgOperand(3),
-                        CI->getArgOperand(4), B, TLI);
+                        CI->getArgOperand(4), B, TLI, AATags);
+  }
 
   return nullptr;
 }
-- 
2.29.2

