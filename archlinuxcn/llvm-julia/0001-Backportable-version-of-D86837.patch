From 3e939f97a38d65d447d70fae277e411f08f7248a Mon Sep 17 00:00:00 2001
From: Yichao Yu <yyc1992@gmail.com>
Date: Sat, 29 Aug 2020 11:21:35 -0400
Subject: [PATCH] Backportable version of D86837

Maintain alias info during libcall simplification.
Keep ABI compatibility by exporting wrapper functions with the old signature.
---
 .../llvm/Transforms/Utils/BuildLibCalls.h     | 106 ++++--
 .../llvm/Transforms/Utils/SimplifyLibCalls.h  |   3 +-
 lib/Transforms/Utils/BuildLibCalls.cpp   | 223 ++++++++++---
 .../lib/Transforms/Utils/SimplifyLibCalls.cpp | 307 ++++++++++++------
 4 files changed, 483 insertions(+), 156 deletions(-)

diff --git a/include/llvm/Transforms/Utils/BuildLibCalls.h b/include/llvm/Transforms/Utils/BuildLibCalls.h
index 3d15b2a7bf2..0fb09ee4905 100644
--- a/include/llvm/Transforms/Utils/BuildLibCalls.h
+++ b/include/llvm/Transforms/Utils/BuildLibCalls.h
@@ -48,102 +48,166 @@ namespace llvm {
   /// pointer. Ptr is required to be some pointer type, and the return value has
   /// 'intptr_t' type.
   Value *emitStrLen(Value *Ptr, IRBuilder<> &B, const DataLayout &DL,
-                    const TargetLibraryInfo *TLI);
+                    const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo);
 
   /// Emit a call to the strdup function to the builder, for the specified
   /// pointer. Ptr is required to be some pointer type, and the return value has
   /// 'i8*' type.
-  Value *emitStrDup(Value *Ptr, IRBuilder<> &B, const TargetLibraryInfo *TLI);
+  Value *emitStrDup(Value *Ptr, IRBuilder<> &B, const TargetLibraryInfo *TLI,
+                    const AAMDNodes &AAInfo);
 
   /// Emit a call to the strnlen function to the builder, for the specified
   /// pointer. Ptr is required to be some pointer type, MaxLen must be of size_t
   /// type, and the return value has 'intptr_t' type.
   Value *emitStrNLen(Value *Ptr, Value *MaxLen, IRBuilder<> &B,
-                     const DataLayout &DL, const TargetLibraryInfo *TLI);
+                     const DataLayout &DL, const TargetLibraryInfo *TLI,
+                     const AAMDNodes &AAInfo);
 
   /// Emit a call to the strchr function to the builder, for the specified
   /// pointer and character. Ptr is required to be some pointer type, and the
   /// return value has 'i8*' type.
   Value *emitStrChr(Value *Ptr, char C, IRBuilder<> &B,
-                    const TargetLibraryInfo *TLI);
+                    const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo);
 
   /// Emit a call to the strncmp function to the builder.
   Value *emitStrNCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilder<> &B,
-                     const DataLayout &DL, const TargetLibraryInfo *TLI);
+                     const DataLayout &DL, const TargetLibraryInfo *TLI,
+                     const AAMDNodes &AAInfo);
 
   /// Emit a call to the strcpy function to the builder, for the specified
   /// pointer arguments.
   Value *emitStrCpy(Value *Dst, Value *Src, IRBuilder<> &B,
-                    const TargetLibraryInfo *TLI);
+                    const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo);
 
   /// Emit a call to the stpcpy function to the builder, for the specified
   /// pointer arguments.
   Value *emitStpCpy(Value *Dst, Value *Src, IRBuilder<> &B,
-                    const TargetLibraryInfo *TLI);
+                    const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo);
 
   /// Emit a call to the strncpy function to the builder, for the specified
   /// pointer arguments and length.
   Value *emitStrNCpy(Value *Dst, Value *Src, Value *Len, IRBuilder<> &B,
-                     const TargetLibraryInfo *TLI);
+                     const TargetLibraryInfo *TLI,
+                     const AAMDNodes &AAInfo);
 
   /// Emit a call to the stpncpy function to the builder, for the specified
   /// pointer arguments and length.
   Value *emitStpNCpy(Value *Dst, Value *Src, Value *Len, IRBuilder<> &B,
-                     const TargetLibraryInfo *TLI);
+                     const TargetLibraryInfo *TLI,
+                     const AAMDNodes &AAInfo);
 
   /// Emit a call to the __memcpy_chk function to the builder. This expects that
   /// the Len and ObjSize have type 'intptr_t' and Dst/Src are pointers.
   Value *emitMemCpyChk(Value *Dst, Value *Src, Value *Len, Value *ObjSize,
                        IRBuilder<> &B, const DataLayout &DL,
-                       const TargetLibraryInfo *TLI);
+                       const TargetLibraryInfo *TLI,
+                       const AAMDNodes &AAInfo);
 
   /// Emit a call to the memchr function. This assumes that Ptr is a pointer,
   /// Val is an i32 value, and Len is an 'intptr_t' value.
   Value *emitMemChr(Value *Ptr, Value *Val, Value *Len, IRBuilder<> &B,
-                    const DataLayout &DL, const TargetLibraryInfo *TLI);
+                    const DataLayout &DL, const TargetLibraryInfo *TLI,
+                    const AAMDNodes &AAInfo);
 
   /// Emit a call to the memcmp function.
   Value *emitMemCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilder<> &B,
-                    const DataLayout &DL, const TargetLibraryInfo *TLI);
+                    const DataLayout &DL, const TargetLibraryInfo *TLI,
+                    const AAMDNodes &AAInfo);
 
   /// Emit a call to the bcmp function.
   Value *emitBCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilder<> &B,
-                  const DataLayout &DL, const TargetLibraryInfo *TLI);
+                  const DataLayout &DL, const TargetLibraryInfo *TLI,
+                  const AAMDNodes &AAInfo);
 
   /// Emit a call to the memccpy function.
   Value *emitMemCCpy(Value *Ptr1, Value *Ptr2, Value *Val, Value *Len,
-                     IRBuilder<> &B, const TargetLibraryInfo *TLI);
+                     IRBuilder<> &B, const TargetLibraryInfo *TLI,
+                     const AAMDNodes &AAInfo);
 
   /// Emit a call to the snprintf function.
   Value *emitSNPrintf(Value *Dest, Value *Size, Value *Fmt,
                       ArrayRef<Value *> Args, IRBuilder<> &B,
-                      const TargetLibraryInfo *TLI);
+                      const TargetLibraryInfo *TLI,
+                      const AAMDNodes &AAInfo);
 
   /// Emit a call to the sprintf function.
   Value *emitSPrintf(Value *Dest, Value *Fmt, ArrayRef<Value *> VariadicArgs,
-                     IRBuilder<> &B, const TargetLibraryInfo *TLI);
+                     IRBuilder<> &B, const TargetLibraryInfo *TLI,
+                     const AAMDNodes &AAInfo);
 
   /// Emit a call to the strcat function.
   Value *emitStrCat(Value *Dest, Value *Src, IRBuilder<> &B,
-                    const TargetLibraryInfo *TLI);
+                    const TargetLibraryInfo *TLI,
+                    const AAMDNodes &AAInfo);
 
   /// Emit a call to the strlcpy function.
   Value *emitStrLCpy(Value *Dest, Value *Src, Value *Size, IRBuilder<> &B,
-                     const TargetLibraryInfo *TLI);
+                     const TargetLibraryInfo *TLI,
+                     const AAMDNodes &AAInfo);
 
   /// Emit a call to the strlcat function.
   Value *emitStrLCat(Value *Dest, Value *Src, Value *Size, IRBuilder<> &B,
-                     const TargetLibraryInfo *TLI);
+                     const TargetLibraryInfo *TLI,
+                     const AAMDNodes &AAInfo);
 
   /// Emit a call to the strncat function.
   Value *emitStrNCat(Value *Dest, Value *Src, Value *Size, IRBuilder<> &B,
-                     const TargetLibraryInfo *TLI);
+                     const TargetLibraryInfo *TLI,
+                     const AAMDNodes &AAInfo);
 
   /// Emit a call to the vsnprintf function.
   Value *emitVSNPrintf(Value *Dest, Value *Size, Value *Fmt, Value *VAList,
-                       IRBuilder<> &B, const TargetLibraryInfo *TLI);
+                       IRBuilder<> &B, const TargetLibraryInfo *TLI,
+                       const AAMDNodes &AAInfo);
 
   /// Emit a call to the vsprintf function.
+  Value *emitVSPrintf(Value *Dest, Value *Fmt, Value *VAList, IRBuilder<> &B,
+                      const TargetLibraryInfo *TLI,
+                      const AAMDNodes &AAInfo);
+
+  Value *emitStrLen(Value *Ptr, IRBuilder<> &B, const DataLayout &DL,
+                    const TargetLibraryInfo *TLI);
+  Value *emitStrDup(Value *Ptr, IRBuilder<> &B, const TargetLibraryInfo *TLI);
+  Value *emitStrNLen(Value *Ptr, Value *MaxLen, IRBuilder<> &B,
+                     const DataLayout &DL, const TargetLibraryInfo *TLI);
+  Value *emitStrChr(Value *Ptr, char C, IRBuilder<> &B,
+                    const TargetLibraryInfo *TLI);
+  Value *emitStrNCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilder<> &B,
+                     const DataLayout &DL, const TargetLibraryInfo *TLI);
+  Value *emitStrCpy(Value *Dst, Value *Src, IRBuilder<> &B,
+                    const TargetLibraryInfo *TLI);
+  Value *emitStpCpy(Value *Dst, Value *Src, IRBuilder<> &B,
+                    const TargetLibraryInfo *TLI);
+  Value *emitStrNCpy(Value *Dst, Value *Src, Value *Len, IRBuilder<> &B,
+                     const TargetLibraryInfo *TLI);
+  Value *emitStpNCpy(Value *Dst, Value *Src, Value *Len, IRBuilder<> &B,
+                     const TargetLibraryInfo *TLI);
+  Value *emitMemCpyChk(Value *Dst, Value *Src, Value *Len, Value *ObjSize,
+                       IRBuilder<> &B, const DataLayout &DL,
+                       const TargetLibraryInfo *TLI);
+  Value *emitMemChr(Value *Ptr, Value *Val, Value *Len, IRBuilder<> &B,
+                    const DataLayout &DL, const TargetLibraryInfo *TLI);
+  Value *emitMemCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilder<> &B,
+                    const DataLayout &DL, const TargetLibraryInfo *TLI);
+  Value *emitBCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilder<> &B,
+                  const DataLayout &DL, const TargetLibraryInfo *TLI);
+  Value *emitMemCCpy(Value *Ptr1, Value *Ptr2, Value *Val, Value *Len,
+                     IRBuilder<> &B, const TargetLibraryInfo *TLI);
+  Value *emitSNPrintf(Value *Dest, Value *Size, Value *Fmt,
+                      ArrayRef<Value *> Args, IRBuilder<> &B,
+                      const TargetLibraryInfo *TLI);
+  Value *emitSPrintf(Value *Dest, Value *Fmt, ArrayRef<Value *> VariadicArgs,
+                     IRBuilder<> &B, const TargetLibraryInfo *TLI);
+  Value *emitStrCat(Value *Dest, Value *Src, IRBuilder<> &B,
+                    const TargetLibraryInfo *TLI);
+  Value *emitStrLCpy(Value *Dest, Value *Src, Value *Size, IRBuilder<> &B,
+                     const TargetLibraryInfo *TLI);
+  Value *emitStrLCat(Value *Dest, Value *Src, Value *Size, IRBuilder<> &B,
+                     const TargetLibraryInfo *TLI);
+  Value *emitStrNCat(Value *Dest, Value *Src, Value *Size, IRBuilder<> &B,
+                     const TargetLibraryInfo *TLI);
+  Value *emitVSNPrintf(Value *Dest, Value *Size, Value *Fmt, Value *VAList,
+                       IRBuilder<> &B, const TargetLibraryInfo *TLI);
   Value *emitVSPrintf(Value *Dest, Value *Fmt, Value *VAList, IRBuilder<> &B,
                       const TargetLibraryInfo *TLI);
 
diff --git a/include/llvm/Transforms/Utils/SimplifyLibCalls.h b/include/llvm/Transforms/Utils/SimplifyLibCalls.h
index 610668adcfa..220af22ea89 100644
--- a/include/llvm/Transforms/Utils/SimplifyLibCalls.h
+++ b/include/llvm/Transforms/Utils/SimplifyLibCalls.h
@@ -227,7 +227,8 @@ private:
   Value *optimizePuts(CallInst *CI, IRBuilder<> &B);
 
   // Helper methods
-  Value *emitStrLenMemCpy(Value *Src, Value *Dst, uint64_t Len, IRBuilder<> &B);
+  Value *emitStrLenMemCpy(Value *Src, Value *Dst, uint64_t Len, IRBuilder<> &B,
+                          const AAMDNodes &AATags);
   void classifyArgUse(Value *Val, Function *F, bool IsFloat,
                       SmallVectorImpl<CallInst *> &SinCalls,
                       SmallVectorImpl<CallInst *> &CosCalls,
diff --git a/lib/Transforms/Utils/BuildLibCalls.cpp b/lib/Transforms/Utils/BuildLibCalls.cpp
index 71316ce8f75..9d504638b8d 100644
--- a/lib/Transforms/Utils/BuildLibCalls.cpp
+++ b/lib/Transforms/Utils/BuildLibCalls.cpp
@@ -824,11 +824,143 @@ Value *llvm::castToCStr(Value *V, IRBuilder<> &B) {
   return B.CreateBitCast(V, B.getInt8PtrTy(AS), "cstr");
 }
 
+Value *llvm::emitStrLen(Value *Ptr, IRBuilder<> &B, const DataLayout &DL,
+                        const TargetLibraryInfo *TLI)
+{
+    return emitStrLen(Ptr, B, DL, TLI, AAMDNodes());
+}
+
+Value *llvm::emitStrDup(Value *Ptr, IRBuilder<> &B, const TargetLibraryInfo *TLI)
+{
+    return emitStrDup(Ptr, B, TLI, AAMDNodes());
+}
+
+// Value *llvm::emitStrNLen(Value *Ptr, Value *MaxLen, IRBuilder<> &B,
+//                          const DataLayout &DL, const TargetLibraryInfo *TLI)
+// {
+//     return emitStrNLen(Ptr, MaxLen, B, DL, TLI, AAMDNodes());
+// }
+
+Value *llvm::emitStrChr(Value *Ptr, char C, IRBuilder<> &B,
+                        const TargetLibraryInfo *TLI)
+{
+    return emitStrChr(Ptr, C, B, TLI, AAMDNodes());
+}
+Value *llvm::emitStrNCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilder<> &B,
+                         const DataLayout &DL, const TargetLibraryInfo *TLI)
+{
+    return emitStrNCmp(Ptr1, Ptr2, Len, B, DL, TLI, AAMDNodes());
+}
+
+Value *llvm::emitStrCpy(Value *Dst, Value *Src, IRBuilder<> &B,
+                        const TargetLibraryInfo *TLI)
+{
+    return emitStrCpy(Dst, Src, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitStpCpy(Value *Dst, Value *Src, IRBuilder<> &B,
+                        const TargetLibraryInfo *TLI)
+{
+    return emitStpCpy(Dst, Src, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitStrNCpy(Value *Dst, Value *Src, Value *Len, IRBuilder<> &B,
+                         const TargetLibraryInfo *TLI)
+{
+    return emitStrNCpy(Dst, Src, Len, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitStpNCpy(Value *Dst, Value *Src, Value *Len, IRBuilder<> &B,
+                         const TargetLibraryInfo *TLI)
+{
+    return emitStpNCpy(Dst, Src, Len, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitMemCpyChk(Value *Dst, Value *Src, Value *Len, Value *ObjSize,
+                           IRBuilder<> &B, const DataLayout &DL,
+                           const TargetLibraryInfo *TLI)
+{
+    return emitMemCpyChk(Dst, Src, Len, ObjSize, B, DL, TLI, AAMDNodes());
+}
+
+Value *llvm::emitMemChr(Value *Ptr, Value *Val, Value *Len, IRBuilder<> &B,
+                        const DataLayout &DL, const TargetLibraryInfo *TLI)
+{
+    return emitMemChr(Ptr, Val, Len, B, DL, TLI, AAMDNodes());
+}
+
+Value *llvm::emitMemCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilder<> &B,
+                        const DataLayout &DL, const TargetLibraryInfo *TLI)
+{
+    return emitMemCmp(Ptr1, Ptr2, Len, B, DL, TLI, AAMDNodes());
+}
+
+Value *llvm::emitBCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilder<> &B,
+                      const DataLayout &DL, const TargetLibraryInfo *TLI)
+{
+    return emitBCmp(Ptr1, Ptr2, Len, B, DL, TLI, AAMDNodes());
+}
+
+Value *llvm::emitMemCCpy(Value *Ptr1, Value *Ptr2, Value *Val, Value *Len,
+                         IRBuilder<> &B, const TargetLibraryInfo *TLI)
+{
+    return emitMemCCpy(Ptr1, Ptr2, Val, Len, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitSNPrintf(Value *Dest, Value *Size, Value *Fmt,
+                          ArrayRef<Value *> Args, IRBuilder<> &B,
+                          const TargetLibraryInfo *TLI)
+{
+    return emitSNPrintf(Dest, Size, Fmt, Args, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitSPrintf(Value *Dest, Value *Fmt, ArrayRef<Value *> VariadicArgs,
+                         IRBuilder<> &B, const TargetLibraryInfo *TLI)
+{
+    return emitSPrintf(Dest, Fmt, VariadicArgs, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitStrCat(Value *Dest, Value *Src, IRBuilder<> &B,
+                        const TargetLibraryInfo *TLI)
+{
+    return emitStrCat(Dest, Src, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitStrLCpy(Value *Dest, Value *Src, Value *Size, IRBuilder<> &B,
+                         const TargetLibraryInfo *TLI)
+{
+    return emitStrLCpy(Dest, Src, Size, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitStrLCat(Value *Dest, Value *Src, Value *Size, IRBuilder<> &B,
+                         const TargetLibraryInfo *TLI)
+{
+    return emitStrLCat(Dest, Src, Size, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitStrNCat(Value *Dest, Value *Src, Value *Size, IRBuilder<> &B,
+                         const TargetLibraryInfo *TLI)
+{
+    return emitStrNCat(Dest, Src, Size, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitVSNPrintf(Value *Dest, Value *Size, Value *Fmt, Value *VAList,
+                           IRBuilder<> &B, const TargetLibraryInfo *TLI)
+{
+    return emitVSNPrintf(Dest, Size, Fmt, VAList, B, TLI, AAMDNodes());
+}
+
+Value *llvm::emitVSPrintf(Value *Dest, Value *Fmt, Value *VAList, IRBuilder<> &B,
+                          const TargetLibraryInfo *TLI)
+{
+    return emitVSPrintf(Dest, Fmt, VAList, B, TLI, AAMDNodes());
+}
+
 static Value *emitLibCall(LibFunc TheLibFunc, Type *ReturnType,
                           ArrayRef<Type *> ParamTypes,
                           ArrayRef<Value *> Operands, IRBuilder<> &B,
                           const TargetLibraryInfo *TLI,
-                          bool IsVaArgs = false) {
+                          bool IsVaArgs = false, const AAMDNodes &AAInfo=AAMDNodes()) {
   if (!TLI->has(TheLibFunc))
     return nullptr;
 
@@ -841,70 +973,72 @@ static Value *emitLibCall(LibFunc TheLibFunc, Type *ReturnType,
   if (const Function *F =
           dyn_cast<Function>(Callee.getCallee()->stripPointerCasts()))
     CI->setCallingConv(F->getCallingConv());
+  CI->setAAMetadata(AAInfo);
   return CI;
 }
 
 Value *llvm::emitStrLen(Value *Ptr, IRBuilder<> &B, const DataLayout &DL,
-                        const TargetLibraryInfo *TLI) {
+                        const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   LLVMContext &Context = B.GetInsertBlock()->getContext();
   return emitLibCall(LibFunc_strlen, DL.getIntPtrType(Context),
-                     B.getInt8PtrTy(), castToCStr(Ptr, B), B, TLI);
+                     B.getInt8PtrTy(), castToCStr(Ptr, B), B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitStrDup(Value *Ptr, IRBuilder<> &B,
-                        const TargetLibraryInfo *TLI) {
+                        const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   return emitLibCall(LibFunc_strdup, B.getInt8PtrTy(), B.getInt8PtrTy(),
-                     castToCStr(Ptr, B), B, TLI);
+                     castToCStr(Ptr, B), B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitStrChr(Value *Ptr, char C, IRBuilder<> &B,
-                        const TargetLibraryInfo *TLI) {
+                        const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   Type *I8Ptr = B.getInt8PtrTy();
   Type *I32Ty = B.getInt32Ty();
   return emitLibCall(LibFunc_strchr, I8Ptr, {I8Ptr, I32Ty},
-                     {castToCStr(Ptr, B), ConstantInt::get(I32Ty, C)}, B, TLI);
+                     {castToCStr(Ptr, B), ConstantInt::get(I32Ty, C)}, B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitStrNCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilder<> &B,
-                         const DataLayout &DL, const TargetLibraryInfo *TLI) {
+                         const DataLayout &DL, const TargetLibraryInfo *TLI,
+                         const AAMDNodes &AAInfo) {
   LLVMContext &Context = B.GetInsertBlock()->getContext();
   return emitLibCall(
       LibFunc_strncmp, B.getInt32Ty(),
       {B.getInt8PtrTy(), B.getInt8PtrTy(), DL.getIntPtrType(Context)},
-      {castToCStr(Ptr1, B), castToCStr(Ptr2, B), Len}, B, TLI);
+      {castToCStr(Ptr1, B), castToCStr(Ptr2, B), Len}, B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitStrCpy(Value *Dst, Value *Src, IRBuilder<> &B,
-                        const TargetLibraryInfo *TLI) {
+                        const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   Type *I8Ptr = B.getInt8PtrTy();
   return emitLibCall(LibFunc_strcpy, I8Ptr, {I8Ptr, I8Ptr},
-                     {castToCStr(Dst, B), castToCStr(Src, B)}, B, TLI);
+                     {castToCStr(Dst, B), castToCStr(Src, B)}, B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitStpCpy(Value *Dst, Value *Src, IRBuilder<> &B,
-                        const TargetLibraryInfo *TLI) {
+                        const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   Type *I8Ptr = B.getInt8PtrTy();
   return emitLibCall(LibFunc_stpcpy, I8Ptr, {I8Ptr, I8Ptr},
-                     {castToCStr(Dst, B), castToCStr(Src, B)}, B, TLI);
+                     {castToCStr(Dst, B), castToCStr(Src, B)}, B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitStrNCpy(Value *Dst, Value *Src, Value *Len, IRBuilder<> &B,
-                         const TargetLibraryInfo *TLI) {
+                         const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   Type *I8Ptr = B.getInt8PtrTy();
   return emitLibCall(LibFunc_strncpy, I8Ptr, {I8Ptr, I8Ptr, Len->getType()},
-                     {castToCStr(Dst, B), castToCStr(Src, B), Len}, B, TLI);
+                     {castToCStr(Dst, B), castToCStr(Src, B), Len}, B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitStpNCpy(Value *Dst, Value *Src, Value *Len, IRBuilder<> &B,
-                         const TargetLibraryInfo *TLI) {
+                         const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   Type *I8Ptr = B.getInt8PtrTy();
   return emitLibCall(LibFunc_stpncpy, I8Ptr, {I8Ptr, I8Ptr, Len->getType()},
-                     {castToCStr(Dst, B), castToCStr(Src, B), Len}, B, TLI);
+                     {castToCStr(Dst, B), castToCStr(Src, B), Len}, B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitMemCpyChk(Value *Dst, Value *Src, Value *Len, Value *ObjSize,
                            IRBuilder<> &B, const DataLayout &DL,
-                           const TargetLibraryInfo *TLI) {
+                           const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   if (!TLI->has(LibFunc_memcpy_chk))
     return nullptr;
 
@@ -923,105 +1057,110 @@ Value *llvm::emitMemCpyChk(Value *Dst, Value *Src, Value *Len, Value *ObjSize,
   if (const Function *F =
           dyn_cast<Function>(MemCpy.getCallee()->stripPointerCasts()))
     CI->setCallingConv(F->getCallingConv());
+  CI->setAAMetadata(AAInfo);
   return CI;
 }
 
 Value *llvm::emitMemChr(Value *Ptr, Value *Val, Value *Len, IRBuilder<> &B,
-                        const DataLayout &DL, const TargetLibraryInfo *TLI) {
+                        const DataLayout &DL, const TargetLibraryInfo *TLI,
+                        const AAMDNodes &AAInfo) {
   LLVMContext &Context = B.GetInsertBlock()->getContext();
   return emitLibCall(
       LibFunc_memchr, B.getInt8PtrTy(),
       {B.getInt8PtrTy(), B.getInt32Ty(), DL.getIntPtrType(Context)},
-      {castToCStr(Ptr, B), Val, Len}, B, TLI);
+      {castToCStr(Ptr, B), Val, Len}, B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitMemCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilder<> &B,
-                        const DataLayout &DL, const TargetLibraryInfo *TLI) {
+                        const DataLayout &DL, const TargetLibraryInfo *TLI,
+                        const AAMDNodes &AAInfo) {
   LLVMContext &Context = B.GetInsertBlock()->getContext();
   return emitLibCall(
       LibFunc_memcmp, B.getInt32Ty(),
       {B.getInt8PtrTy(), B.getInt8PtrTy(), DL.getIntPtrType(Context)},
-      {castToCStr(Ptr1, B), castToCStr(Ptr2, B), Len}, B, TLI);
+      {castToCStr(Ptr1, B), castToCStr(Ptr2, B), Len}, B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitBCmp(Value *Ptr1, Value *Ptr2, Value *Len, IRBuilder<> &B,
-                      const DataLayout &DL, const TargetLibraryInfo *TLI) {
+                      const DataLayout &DL, const TargetLibraryInfo *TLI,
+                      const AAMDNodes &AAInfo) {
   LLVMContext &Context = B.GetInsertBlock()->getContext();
   return emitLibCall(
       LibFunc_bcmp, B.getInt32Ty(),
       {B.getInt8PtrTy(), B.getInt8PtrTy(), DL.getIntPtrType(Context)},
-      {castToCStr(Ptr1, B), castToCStr(Ptr2, B), Len}, B, TLI);
+      {castToCStr(Ptr1, B), castToCStr(Ptr2, B), Len}, B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitMemCCpy(Value *Ptr1, Value *Ptr2, Value *Val, Value *Len,
-                         IRBuilder<> &B, const TargetLibraryInfo *TLI) {
+                         IRBuilder<> &B, const TargetLibraryInfo *TLI,
+                         const AAMDNodes &AAInfo) {
   return emitLibCall(
       LibFunc_memccpy, B.getInt8PtrTy(),
       {B.getInt8PtrTy(), B.getInt8PtrTy(), B.getInt32Ty(), Len->getType()},
-      {Ptr1, Ptr2, Val, Len}, B, TLI);
+      {Ptr1, Ptr2, Val, Len}, B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitSNPrintf(Value *Dest, Value *Size, Value *Fmt,
                           ArrayRef<Value *> VariadicArgs, IRBuilder<> &B,
-                          const TargetLibraryInfo *TLI) {
+                          const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   SmallVector<Value *, 8> Args{castToCStr(Dest, B), Size, castToCStr(Fmt, B)};
   Args.insert(Args.end(), VariadicArgs.begin(), VariadicArgs.end());
   return emitLibCall(LibFunc_snprintf, B.getInt32Ty(),
                      {B.getInt8PtrTy(), Size->getType(), B.getInt8PtrTy()},
-                     Args, B, TLI, /*IsVaArgs=*/true);
+                     Args, B, TLI, /*IsVaArgs=*/true, AAInfo);
 }
 
 Value *llvm::emitSPrintf(Value *Dest, Value *Fmt,
                          ArrayRef<Value *> VariadicArgs, IRBuilder<> &B,
-                         const TargetLibraryInfo *TLI) {
+                         const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   SmallVector<Value *, 8> Args{castToCStr(Dest, B), castToCStr(Fmt, B)};
   Args.insert(Args.end(), VariadicArgs.begin(), VariadicArgs.end());
   return emitLibCall(LibFunc_sprintf, B.getInt32Ty(),
                      {B.getInt8PtrTy(), B.getInt8PtrTy()}, Args, B, TLI,
-                     /*IsVaArgs=*/true);
+                     /*IsVaArgs=*/true, AAInfo);
 }
 
 Value *llvm::emitStrCat(Value *Dest, Value *Src, IRBuilder<> &B,
-                        const TargetLibraryInfo *TLI) {
+                        const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   return emitLibCall(LibFunc_strcat, B.getInt8PtrTy(),
                      {B.getInt8PtrTy(), B.getInt8PtrTy()},
-                     {castToCStr(Dest, B), castToCStr(Src, B)}, B, TLI);
+                     {castToCStr(Dest, B), castToCStr(Src, B)}, B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitStrLCpy(Value *Dest, Value *Src, Value *Size, IRBuilder<> &B,
-                         const TargetLibraryInfo *TLI) {
+                         const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   return emitLibCall(LibFunc_strlcpy, Size->getType(),
                      {B.getInt8PtrTy(), B.getInt8PtrTy(), Size->getType()},
-                     {castToCStr(Dest, B), castToCStr(Src, B), Size}, B, TLI);
+                     {castToCStr(Dest, B), castToCStr(Src, B), Size}, B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitStrLCat(Value *Dest, Value *Src, Value *Size, IRBuilder<> &B,
-                         const TargetLibraryInfo *TLI) {
+                         const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   return emitLibCall(LibFunc_strlcat, Size->getType(),
                      {B.getInt8PtrTy(), B.getInt8PtrTy(), Size->getType()},
-                     {castToCStr(Dest, B), castToCStr(Src, B), Size}, B, TLI);
+                     {castToCStr(Dest, B), castToCStr(Src, B), Size}, B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitStrNCat(Value *Dest, Value *Src, Value *Size, IRBuilder<> &B,
-                         const TargetLibraryInfo *TLI) {
+                         const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   return emitLibCall(LibFunc_strncat, B.getInt8PtrTy(),
                      {B.getInt8PtrTy(), B.getInt8PtrTy(), Size->getType()},
-                     {castToCStr(Dest, B), castToCStr(Src, B), Size}, B, TLI);
+                     {castToCStr(Dest, B), castToCStr(Src, B), Size}, B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitVSNPrintf(Value *Dest, Value *Size, Value *Fmt, Value *VAList,
-                           IRBuilder<> &B, const TargetLibraryInfo *TLI) {
+                           IRBuilder<> &B, const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   return emitLibCall(
       LibFunc_vsnprintf, B.getInt32Ty(),
       {B.getInt8PtrTy(), Size->getType(), B.getInt8PtrTy(), VAList->getType()},
-      {castToCStr(Dest, B), Size, castToCStr(Fmt, B), VAList}, B, TLI);
+      {castToCStr(Dest, B), Size, castToCStr(Fmt, B), VAList}, B, TLI, false, AAInfo);
 }
 
 Value *llvm::emitVSPrintf(Value *Dest, Value *Fmt, Value *VAList,
-                          IRBuilder<> &B, const TargetLibraryInfo *TLI) {
+                          IRBuilder<> &B, const TargetLibraryInfo *TLI, const AAMDNodes &AAInfo) {
   return emitLibCall(LibFunc_vsprintf, B.getInt32Ty(),
                      {B.getInt8PtrTy(), B.getInt8PtrTy(), VAList->getType()},
-                     {castToCStr(Dest, B), castToCStr(Fmt, B), VAList}, B, TLI);
+                     {castToCStr(Dest, B), castToCStr(Fmt, B), VAList}, B, TLI, false, AAInfo);
 }
 
 /// Append a suffix to the function name according to the type of 'Op'.
diff --git a/lib/Transforms/Utils/SimplifyLibCalls.cpp b/lib/Transforms/Utils/SimplifyLibCalls.cpp
index fa3a9d21f3d..8d8ad8b5eae 100644
--- a/lib/Transforms/Utils/SimplifyLibCalls.cpp
+++ b/lib/Transforms/Utils/SimplifyLibCalls.cpp
@@ -270,14 +270,16 @@ Value *LibCallSimplifier::optimizeStrCat(CallInst *CI, IRBuilder<> &B) {
   if (Len == 0)
     return Dst;
 
-  return emitStrLenMemCpy(Src, Dst, Len, B);
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
+  return emitStrLenMemCpy(Src, Dst, Len, B, AATags);
 }
 
 Value *LibCallSimplifier::emitStrLenMemCpy(Value *Src, Value *Dst, uint64_t Len,
-                                           IRBuilder<> &B) {
+                                           IRBuilder<> &B, const AAMDNodes &AATags) {
   // We need to find the end of the destination string.  That's where the
   // memory is to be moved to. We just generate a call to strlen.
-  Value *DstLen = emitStrLen(Dst, B, DL, TLI);
+  Value *DstLen = emitStrLen(Dst, B, DL, TLI, AATags);
   if (!DstLen)
     return nullptr;
 
@@ -290,7 +292,8 @@ Value *LibCallSimplifier::emitStrLenMemCpy(Value *Src, Value *Dst, uint64_t Len,
   // concatenation for us.  Make a memcpy to copy the nul byte with align = 1.
   B.CreateMemCpy(
       CpyDst, Align::None(), Src, Align::None(),
-      ConstantInt::get(DL.getIntPtrType(Src->getContext()), Len + 1));
+      ConstantInt::get(DL.getIntPtrType(Src->getContext()), Len + 1),
+      false, AATags.TBAA, nullptr, AATags.Scope, AATags.NoAlias);
   return Dst;
 }
 
@@ -332,9 +335,11 @@ Value *LibCallSimplifier::optimizeStrNCat(CallInst *CI, IRBuilder<> &B) {
   if (Len < SrcLen)
     return nullptr;
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   // strncat(x, s, c) -> strcat(x, s)
   // s is constant so the strcat can be optimized further.
-  return emitStrLenMemCpy(Src, Dst, SrcLen, B);
+  return emitStrLenMemCpy(Src, Dst, SrcLen, B, AATags);
 }
 
 Value *LibCallSimplifier::optimizeStrChr(CallInst *CI, IRBuilder<> &B) {
@@ -343,6 +348,9 @@ Value *LibCallSimplifier::optimizeStrChr(CallInst *CI, IRBuilder<> &B) {
   Value *SrcStr = CI->getArgOperand(0);
   annotateNonNullBasedOnAccess(CI, 0);
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
+
   // If the second operand is non-constant, see if we can compute the length
   // of the input string and turn this into memchr.
   ConstantInt *CharC = dyn_cast<ConstantInt>(CI->getArgOperand(1));
@@ -357,7 +365,7 @@ Value *LibCallSimplifier::optimizeStrChr(CallInst *CI, IRBuilder<> &B) {
 
     return emitMemChr(SrcStr, CI->getArgOperand(1), // include nul.
                       ConstantInt::get(DL.getIntPtrType(CI->getContext()), Len),
-                      B, DL, TLI);
+                      B, DL, TLI, AATags);
   }
 
   // Otherwise, the character is a constant, see if the first argument is
@@ -365,7 +373,7 @@ Value *LibCallSimplifier::optimizeStrChr(CallInst *CI, IRBuilder<> &B) {
   StringRef Str;
   if (!getConstantStringInfo(SrcStr, Str)) {
     if (CharC->isZero()) // strchr(p, 0) -> p + strlen(p)
-      if (Value *StrLen = emitStrLen(SrcStr, B, DL, TLI))
+      if (Value *StrLen = emitStrLen(SrcStr, B, DL, TLI, AATags))
         return B.CreateGEP(B.getInt8Ty(), SrcStr, StrLen, "strchr");
     return nullptr;
   }
@@ -394,8 +402,11 @@ Value *LibCallSimplifier::optimizeStrRChr(CallInst *CI, IRBuilder<> &B) {
   StringRef Str;
   if (!getConstantStringInfo(SrcStr, Str)) {
     // strrchr(s, 0) -> strchr(s, 0)
-    if (CharC->isZero())
-      return emitStrChr(SrcStr, '\0', B, TLI);
+    if (CharC->isZero()) {
+      AAMDNodes AATags;
+      CI->getAAMetadata(AATags);
+      return emitStrChr(SrcStr, '\0', B, TLI, AATags);
+    }
     return nullptr;
   }
 
@@ -423,13 +434,20 @@ Value *LibCallSimplifier::optimizeStrCmp(CallInst *CI, IRBuilder<> &B) {
   if (HasStr1 && HasStr2)
     return ConstantInt::get(CI->getType(), Str1.compare(Str2));
 
-  if (HasStr1 && Str1.empty()) // strcmp("", x) -> -*x
-    return B.CreateNeg(B.CreateZExt(
-        B.CreateLoad(B.getInt8Ty(), Str2P, "strcmpload"), CI->getType()));
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
 
-  if (HasStr2 && Str2.empty()) // strcmp(x,"") -> *x
-    return B.CreateZExt(B.CreateLoad(B.getInt8Ty(), Str1P, "strcmpload"),
-                        CI->getType());
+  if (HasStr1 && Str1.empty()) { // strcmp("", x) -> -*x
+    auto load = B.CreateLoad(B.getInt8Ty(), Str2P, "strcmpload");
+    load->setAAMetadata(AATags);
+    return B.CreateNeg(B.CreateZExt(load, CI->getType()));
+  }
+
+  if (HasStr2 && Str2.empty()) { // strcmp(x,"") -> *x
+    auto load = B.CreateLoad(B.getInt8Ty(), Str1P, "strcmpload");
+    load->setAAMetadata(AATags);
+    return B.CreateZExt(load, CI->getType());
+  }
 
   // strcmp(P, "x") -> memcmp(P, "x", 2)
   uint64_t Len1 = GetStringLength(Str1P);
@@ -443,7 +461,7 @@ Value *LibCallSimplifier::optimizeStrCmp(CallInst *CI, IRBuilder<> &B) {
     return emitMemCmp(Str1P, Str2P,
                       ConstantInt::get(DL.getIntPtrType(CI->getContext()),
                                        std::min(Len1, Len2)),
-                      B, DL, TLI);
+                      B, DL, TLI, AATags);
   }
 
   // strcmp to memcmp
@@ -452,13 +470,13 @@ Value *LibCallSimplifier::optimizeStrCmp(CallInst *CI, IRBuilder<> &B) {
       return emitMemCmp(
           Str1P, Str2P,
           ConstantInt::get(DL.getIntPtrType(CI->getContext()), Len2), B, DL,
-          TLI);
+          TLI, AATags);
   } else if (HasStr1 && !HasStr2) {
     if (canTransformToMemCmp(CI, Str2P, Len1, DL))
       return emitMemCmp(
           Str1P, Str2P,
           ConstantInt::get(DL.getIntPtrType(CI->getContext()), Len1), B, DL,
-          TLI);
+          TLI, AATags);
   }
 
   annotateNonNullBasedOnAccess(CI, {0, 1});
@@ -484,8 +502,10 @@ Value *LibCallSimplifier::optimizeStrNCmp(CallInst *CI, IRBuilder<> &B) {
   if (Length == 0) // strncmp(x,y,0)   -> 0
     return ConstantInt::get(CI->getType(), 0);
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   if (Length == 1) // strncmp(x,y,1) -> memcmp(x,y,1)
-    return emitMemCmp(Str1P, Str2P, Size, B, DL, TLI);
+    return emitMemCmp(Str1P, Str2P, Size, B, DL, TLI, AATags);
 
   StringRef Str1, Str2;
   bool HasStr1 = getConstantStringInfo(Str1P, Str1);
@@ -498,13 +518,17 @@ Value *LibCallSimplifier::optimizeStrNCmp(CallInst *CI, IRBuilder<> &B) {
     return ConstantInt::get(CI->getType(), SubStr1.compare(SubStr2));
   }
 
-  if (HasStr1 && Str1.empty()) // strncmp("", x, n) -> -*x
-    return B.CreateNeg(B.CreateZExt(
-        B.CreateLoad(B.getInt8Ty(), Str2P, "strcmpload"), CI->getType()));
+  if (HasStr1 && Str1.empty()) { // strncmp("", x, n) -> -*x
+    auto load = B.CreateLoad(B.getInt8Ty(), Str2P, "strcmpload");
+    load->setAAMetadata(AATags);
+    return B.CreateNeg(B.CreateZExt(load, CI->getType()));
+  }
 
-  if (HasStr2 && Str2.empty()) // strncmp(x, "", n) -> *x
-    return B.CreateZExt(B.CreateLoad(B.getInt8Ty(), Str1P, "strcmpload"),
-                        CI->getType());
+  if (HasStr2 && Str2.empty()) { // strncmp(x, "", n) -> *x
+    auto load = B.CreateLoad(B.getInt8Ty(), Str1P, "strcmpload");
+    load->setAAMetadata(AATags);
+    return B.CreateZExt(load, CI->getType());
+  }
 
   uint64_t Len1 = GetStringLength(Str1P);
   if (Len1)
@@ -520,14 +544,14 @@ Value *LibCallSimplifier::optimizeStrNCmp(CallInst *CI, IRBuilder<> &B) {
       return emitMemCmp(
           Str1P, Str2P,
           ConstantInt::get(DL.getIntPtrType(CI->getContext()), Len2), B, DL,
-          TLI);
+          TLI, AATags);
   } else if (HasStr1 && !HasStr2) {
     Len1 = std::min(Len1, Length);
     if (canTransformToMemCmp(CI, Str2P, Len1, DL))
       return emitMemCmp(
           Str1P, Str2P,
           ConstantInt::get(DL.getIntPtrType(CI->getContext()), Len1), B, DL,
-          TLI);
+          TLI, AATags);
   }
 
   return nullptr;
@@ -539,8 +563,11 @@ Value *LibCallSimplifier::optimizeStrNDup(CallInst *CI, IRBuilder<> &B) {
   uint64_t SrcLen = GetStringLength(Src);
   if (SrcLen && Size) {
     annotateDereferenceableBytes(CI, 0, SrcLen);
-    if (SrcLen <= Size->getZExtValue() + 1)
-      return emitStrDup(Src, B, TLI);
+    if (SrcLen <= Size->getZExtValue() + 1) {
+      AAMDNodes AATags;
+      CI->getAAMetadata(AATags);
+      return emitStrDup(Src, B, TLI, AATags);
+    }
   }
 
   return nullptr;
@@ -559,11 +586,14 @@ Value *LibCallSimplifier::optimizeStrCpy(CallInst *CI, IRBuilder<> &B) {
   else
     return nullptr;
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   // We have enough information to now generate the memcpy call to do the
   // copy for us.  Make a memcpy to copy the nul byte with align = 1.
   CallInst *NewCI =
       B.CreateMemCpy(Dst, Align::None(), Src, Align::None(),
-                     ConstantInt::get(DL.getIntPtrType(CI->getContext()), Len));
+                     ConstantInt::get(DL.getIntPtrType(CI->getContext()), Len),
+                     false, AATags.TBAA, nullptr, AATags.Scope, AATags.NoAlias);
   NewCI->setAttributes(CI->getAttributes());
   return Dst;
 }
@@ -571,8 +601,10 @@ Value *LibCallSimplifier::optimizeStrCpy(CallInst *CI, IRBuilder<> &B) {
 Value *LibCallSimplifier::optimizeStpCpy(CallInst *CI, IRBuilder<> &B) {
   Function *Callee = CI->getCalledFunction();
   Value *Dst = CI->getArgOperand(0), *Src = CI->getArgOperand(1);
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   if (Dst == Src) { // stpcpy(x,x)  -> x+strlen(x)
-    Value *StrLen = emitStrLen(Src, B, DL, TLI);
+    Value *StrLen = emitStrLen(Src, B, DL, TLI, AATags);
     return StrLen ? B.CreateInBoundsGEP(B.getInt8Ty(), Dst, StrLen) : nullptr;
   }
 
@@ -591,7 +623,8 @@ Value *LibCallSimplifier::optimizeStpCpy(CallInst *CI, IRBuilder<> &B) {
   // We have enough information to now generate the memcpy call to do the
   // copy for us.  Make a memcpy to copy the nul byte with align = 1.
   CallInst *NewCI =
-      B.CreateMemCpy(Dst, Align::None(), Src, Align::None(), LenV);
+      B.CreateMemCpy(Dst, Align::None(), Src, Align::None(), LenV,
+      false, AATags.TBAA, nullptr, AATags.Scope, AATags.NoAlias);
   NewCI->setAttributes(CI->getAttributes());
   return DstEnd;
 }
@@ -624,9 +657,12 @@ Value *LibCallSimplifier::optimizeStrNCpy(CallInst *CI, IRBuilder<> &B) {
     return nullptr;
   }
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   if (SrcLen == 0) {
     // strncpy(x, "", y) -> memset(align 1 x, '\0', y)
-    CallInst *NewCI = B.CreateMemSet(Dst, B.getInt8('\0'), Size, Align::None());
+    CallInst *NewCI = B.CreateMemSet(Dst, B.getInt8('\0'), Size, Align::None(),
+                                     false, AATags.TBAA, AATags.Scope, AATags.NoAlias);
     AttrBuilder ArgAttrs(CI->getAttributes().getParamAttributes(0));
     NewCI->setAttributes(NewCI->getAttributes().addParamAttributes(
         CI->getContext(), 0, ArgAttrs));
@@ -640,7 +676,8 @@ Value *LibCallSimplifier::optimizeStrNCpy(CallInst *CI, IRBuilder<> &B) {
   Type *PT = Callee->getFunctionType()->getParamType(0);
   // strncpy(x, s, c) -> memcpy(align 1 x, align 1 s, c) [s and c are constant]
   CallInst *NewCI = B.CreateMemCpy(Dst, Align::None(), Src, Align::None(),
-                                   ConstantInt::get(DL.getIntPtrType(PT), Len));
+                                   ConstantInt::get(DL.getIntPtrType(PT), Len),
+                                   false, AATags.TBAA, nullptr, AATags.Scope, AATags.NoAlias);
   NewCI->setAttributes(CI->getAttributes());
   return Dst;
 }
@@ -729,9 +766,13 @@ Value *LibCallSimplifier::optimizeStringLength(CallInst *CI, IRBuilder<> &B,
 
   // strlen(x) != 0 --> *x != 0
   // strlen(x) == 0 --> *x == 0
-  if (isOnlyUsedInZeroEqualityComparison(CI))
-    return B.CreateZExt(B.CreateLoad(B.getIntNTy(CharSize), Src, "strlenfirst"),
-                        CI->getType());
+  if (isOnlyUsedInZeroEqualityComparison(CI)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
+    auto load = B.CreateLoad(B.getIntNTy(CharSize), Src, "strlenfirst");
+    load->setAAMetadata(AATags);
+    return B.CreateZExt(load, CI->getType());
+  }
 
   return nullptr;
 }
@@ -774,8 +815,11 @@ Value *LibCallSimplifier::optimizeStrPBrk(CallInst *CI, IRBuilder<> &B) {
   }
 
   // strpbrk(s, "a") -> strchr(s, 'a')
-  if (HasS2 && S2.size() == 1)
-    return emitStrChr(CI->getArgOperand(0), S2[0], B, TLI);
+  if (HasS2 && S2.size() == 1) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
+    return emitStrChr(CI->getArgOperand(0), S2[0], B, TLI, AATags);
+  }
 
   return nullptr;
 }
@@ -830,8 +874,11 @@ Value *LibCallSimplifier::optimizeStrCSpn(CallInst *CI, IRBuilder<> &B) {
   }
 
   // strcspn(s, "") -> strlen(s)
-  if (HasS2 && S2.empty())
-    return emitStrLen(CI->getArgOperand(0), B, DL, TLI);
+  if (HasS2 && S2.empty()) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
+    return emitStrLen(CI->getArgOperand(0), B, DL, TLI, AATags);
+  }
 
   return nullptr;
 }
@@ -841,13 +888,15 @@ Value *LibCallSimplifier::optimizeStrStr(CallInst *CI, IRBuilder<> &B) {
   if (CI->getArgOperand(0) == CI->getArgOperand(1))
     return B.CreateBitCast(CI->getArgOperand(0), CI->getType());
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   // fold strstr(a, b) == a -> strncmp(a, b, strlen(b)) == 0
   if (isOnlyUsedInEqualityComparison(CI, CI->getArgOperand(0))) {
-    Value *StrLen = emitStrLen(CI->getArgOperand(1), B, DL, TLI);
+    Value *StrLen = emitStrLen(CI->getArgOperand(1), B, DL, TLI, AATags);
     if (!StrLen)
       return nullptr;
     Value *StrNCmp = emitStrNCmp(CI->getArgOperand(0), CI->getArgOperand(1),
-                                 StrLen, B, DL, TLI);
+                                 StrLen, B, DL, TLI, AATags);
     if (!StrNCmp)
       return nullptr;
     for (auto UI = CI->user_begin(), UE = CI->user_end(); UI != UE;) {
@@ -885,7 +934,7 @@ Value *LibCallSimplifier::optimizeStrStr(CallInst *CI, IRBuilder<> &B) {
 
   // fold strstr(x, "y") -> strchr(x, 'y').
   if (HasStr2 && ToFindStr.size() == 1) {
-    Value *StrChr = emitStrChr(CI->getArgOperand(0), ToFindStr[0], B, TLI);
+    Value *StrChr = emitStrChr(CI->getArgOperand(0), ToFindStr[0], B, TLI, AATags);
     return StrChr ? B.CreateBitCast(StrChr, CI->getType()) : nullptr;
   }
 
@@ -993,14 +1042,16 @@ static Value *optimizeMemCmpConstantSize(CallInst *CI, Value *LHS, Value *RHS,
   if (Len == 0) // memcmp(s1,s2,0) -> 0
     return Constant::getNullValue(CI->getType());
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   // memcmp(S1,S2,1) -> *(unsigned char*)LHS - *(unsigned char*)RHS
   if (Len == 1) {
-    Value *LHSV =
-        B.CreateZExt(B.CreateLoad(B.getInt8Ty(), castToCStr(LHS, B), "lhsc"),
-                     CI->getType(), "lhsv");
-    Value *RHSV =
-        B.CreateZExt(B.CreateLoad(B.getInt8Ty(), castToCStr(RHS, B), "rhsc"),
-                     CI->getType(), "rhsv");
+    auto load1 = B.CreateLoad(B.getInt8Ty(), castToCStr(LHS, B), "lhsc");
+    load1->setAAMetadata(AATags);
+    Value *LHSV = B.CreateZExt(load1, CI->getType(), "lhsv");
+    auto load2 = B.CreateLoad(B.getInt8Ty(), castToCStr(RHS, B), "rhsc");
+    load2->setAAMetadata(AATags);
+    Value *RHSV = B.CreateZExt(load2, CI->getType(), "rhsv");
     return B.CreateSub(LHSV, RHSV, "chardiff");
   }
 
@@ -1031,11 +1082,13 @@ static Value *optimizeMemCmpConstantSize(CallInst *CI, Value *LHS, Value *RHS,
         Type *LHSPtrTy =
             IntType->getPointerTo(LHS->getType()->getPointerAddressSpace());
         LHSV = B.CreateLoad(IntType, B.CreateBitCast(LHS, LHSPtrTy), "lhsv");
+        cast<LoadInst>(LHSV)->setAAMetadata(AATags);
       }
       if (!RHSV) {
         Type *RHSPtrTy =
             IntType->getPointerTo(RHS->getType()->getPointerAddressSpace());
         RHSV = B.CreateLoad(IntType, B.CreateBitCast(RHS, RHSPtrTy), "rhsv");
+        cast<LoadInst>(RHSV)->setAAMetadata(AATags);
       }
       return B.CreateZExt(B.CreateICmpNE(LHSV, RHSV), CI->getType(), "memcmp");
     }
@@ -1099,7 +1152,9 @@ Value *LibCallSimplifier::optimizeMemCmp(CallInst *CI, IRBuilder<> &B) {
     Value *LHS = CI->getArgOperand(0);
     Value *RHS = CI->getArgOperand(1);
     Value *Size = CI->getArgOperand(2);
-    return emitBCmp(LHS, RHS, Size, B, DL, TLI);
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
+    return emitBCmp(LHS, RHS, Size, B, DL, TLI, AATags);
   }
 
   return nullptr;
@@ -1115,9 +1170,13 @@ Value *LibCallSimplifier::optimizeMemCpy(CallInst *CI, IRBuilder<> &B) {
   if (isa<IntrinsicInst>(CI))
     return nullptr;
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   // memcpy(x, y, n) -> llvm.memcpy(align 1 x, align 1 y, n)
   CallInst *NewCI = B.CreateMemCpy(CI->getArgOperand(0), Align::None(),
-                                   CI->getArgOperand(1), Align::None(), Size);
+                                   CI->getArgOperand(1), Align::None(), Size,
+                                   false, AATags.TBAA, AATags.TBAAStruct,
+                                   AATags.Scope, AATags.NoAlias);
   NewCI->setAttributes(CI->getAttributes());
   return CI->getArgOperand(0);
 }
@@ -1142,12 +1201,16 @@ Value *LibCallSimplifier::optimizeMemCCpy(CallInst *CI, IRBuilder<> &B) {
     return nullptr;
   }
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
+
   // Wrap arg 'c' of type int to char
   size_t Pos = SrcStr.find(StopChar->getSExtValue() & 0xFF);
   if (Pos == StringRef::npos) {
     if (N->getZExtValue() <= SrcStr.size()) {
       B.CreateMemCpy(Dst, Align::None(), Src, Align::None(),
-                     CI->getArgOperand(3));
+                     CI->getArgOperand(3),
+                     false, AATags.TBAA, nullptr, AATags.Scope, AATags.NoAlias);
       return Constant::getNullValue(CI->getType());
     }
     return nullptr;
@@ -1156,7 +1219,8 @@ Value *LibCallSimplifier::optimizeMemCCpy(CallInst *CI, IRBuilder<> &B) {
   Value *NewN =
       ConstantInt::get(N->getType(), std::min(uint64_t(Pos + 1), N->getZExtValue()));
   // memccpy -> llvm.memcpy
-  B.CreateMemCpy(Dst, Align::None(), Src, Align::None(), NewN);
+  B.CreateMemCpy(Dst, Align::None(), Src, Align::None(), NewN,
+                 false, AATags.TBAA, nullptr, AATags.Scope, AATags.NoAlias);
   return Pos + 1 <= N->getZExtValue()
              ? B.CreateInBoundsGEP(B.getInt8Ty(), Dst, NewN)
              : Constant::getNullValue(CI->getType());
@@ -1165,9 +1229,12 @@ Value *LibCallSimplifier::optimizeMemCCpy(CallInst *CI, IRBuilder<> &B) {
 Value *LibCallSimplifier::optimizeMemPCpy(CallInst *CI, IRBuilder<> &B) {
   Value *Dst = CI->getArgOperand(0);
   Value *N = CI->getArgOperand(2);
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   // mempcpy(x, y, n) -> llvm.memcpy(align 1 x, align 1 y, n), x + n
   CallInst *NewCI = B.CreateMemCpy(Dst, Align::None(), CI->getArgOperand(1),
-                                   Align::None(), N);
+                                   Align::None(), N,
+                                   false, AATags.TBAA, nullptr, AATags.Scope, AATags.NoAlias);
   NewCI->setAttributes(CI->getAttributes());
   return B.CreateInBoundsGEP(B.getInt8Ty(), Dst, N);
 }
@@ -1178,9 +1245,12 @@ Value *LibCallSimplifier::optimizeMemMove(CallInst *CI, IRBuilder<> &B) {
   if (isa<IntrinsicInst>(CI))
     return nullptr;
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   // memmove(x, y, n) -> llvm.memmove(align 1 x, align 1 y, n)
   CallInst *NewCI = B.CreateMemMove(CI->getArgOperand(0), Align::None(),
-                                    CI->getArgOperand(1), Align::None(), Size);
+                                    CI->getArgOperand(1), Align::None(), Size,
+                                    false, AATags.TBAA, AATags.Scope, AATags.NoAlias);
   NewCI->setAttributes(CI->getAttributes());
   return CI->getArgOperand(0);
 }
@@ -1238,10 +1308,13 @@ Value *LibCallSimplifier::optimizeMemSet(CallInst *CI, IRBuilder<> &B) {
   if (auto *Calloc = foldMallocMemset(CI, B))
     return Calloc;
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   // memset(p, v, n) -> llvm.memset(align 1 p, v, n)
   Value *Val = B.CreateIntCast(CI->getArgOperand(1), B.getInt8Ty(), false);
   CallInst *NewCI =
-      B.CreateMemSet(CI->getArgOperand(0), Val, Size, Align::None());
+      B.CreateMemSet(CI->getArgOperand(0), Val, Size, Align::None(),
+                     false, AATags.TBAA, AATags.Scope, AATags.NoAlias);
   NewCI->setAttributes(CI->getAttributes());
   return CI->getArgOperand(0);
 }
@@ -2468,6 +2541,8 @@ Value *LibCallSimplifier::optimizeSPrintFString(CallInst *CI, IRBuilder<> &B) {
   if (!getConstantStringInfo(CI->getArgOperand(1), FormatStr))
     return nullptr;
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   // If we just have a format string (nothing else crazy) transform it.
   if (CI->getNumArgOperands() == 2) {
     // Make sure there's no % in the constant array.  We could try to handle
@@ -2480,7 +2555,8 @@ Value *LibCallSimplifier::optimizeSPrintFString(CallInst *CI, IRBuilder<> &B) {
         CI->getArgOperand(0), Align::None(), CI->getArgOperand(1),
         Align::None(),
         ConstantInt::get(DL.getIntPtrType(CI->getContext()),
-                         FormatStr.size() + 1)); // Copy the null byte.
+                         FormatStr.size() + 1),
+        false, AATags.TBAA, nullptr, AATags.Scope, AATags.NoAlias); // Copy the null byte.
     return ConstantInt::get(CI->getType(), FormatStr.size());
   }
 
@@ -2497,9 +2573,9 @@ Value *LibCallSimplifier::optimizeSPrintFString(CallInst *CI, IRBuilder<> &B) {
       return nullptr;
     Value *V = B.CreateTrunc(CI->getArgOperand(2), B.getInt8Ty(), "char");
     Value *Ptr = castToCStr(CI->getArgOperand(0), B);
-    B.CreateStore(V, Ptr);
+    B.CreateStore(V, Ptr)->setAAMetadata(AATags);
     Ptr = B.CreateGEP(B.getInt8Ty(), Ptr, B.getInt32(1), "nul");
-    B.CreateStore(B.getInt8(0), Ptr);
+    B.CreateStore(B.getInt8(0), Ptr)->setAAMetadata(AATags);
 
     return ConstantInt::get(CI->getType(), 1);
   }
@@ -2510,13 +2586,14 @@ Value *LibCallSimplifier::optimizeSPrintFString(CallInst *CI, IRBuilder<> &B) {
     if (!CI->getArgOperand(2)->getType()->isPointerTy())
       return nullptr;
 
-    Value *Len = emitStrLen(CI->getArgOperand(2), B, DL, TLI);
+    Value *Len = emitStrLen(CI->getArgOperand(2), B, DL, TLI, AATags);
     if (!Len)
       return nullptr;
     Value *IncLen =
         B.CreateAdd(Len, ConstantInt::get(Len->getType(), 1), "leninc");
     B.CreateMemCpy(CI->getArgOperand(0), Align::None(), CI->getArgOperand(2),
-                   Align::None(), IncLen);
+                   Align::None(), IncLen,
+                   false, AATags.TBAA, nullptr, AATags.Scope, AATags.NoAlias);
 
     // The sprintf result is the unincremented number of bytes in the string.
     return B.CreateIntCast(Len, CI->getType(), false);
@@ -2572,6 +2649,8 @@ Value *LibCallSimplifier::optimizeSnPrintFString(CallInst *CI, IRBuilder<> &B) {
   if (!getConstantStringInfo(CI->getArgOperand(2), FormatStr))
     return nullptr;
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   // If we just have a format string (nothing else crazy) transform it.
   if (CI->getNumArgOperands() == 3) {
     // Make sure there's no % in the constant array.  We could try to handle
@@ -2590,7 +2669,8 @@ Value *LibCallSimplifier::optimizeSnPrintFString(CallInst *CI, IRBuilder<> &B) {
         CI->getArgOperand(0), Align::None(), CI->getArgOperand(2),
         Align::None(),
         ConstantInt::get(DL.getIntPtrType(CI->getContext()),
-                         FormatStr.size() + 1)); // Copy the null byte.
+                         FormatStr.size() + 1),
+        false, AATags.TBAA, nullptr, AATags.Scope, AATags.NoAlias); // Copy the null byte.
     return ConstantInt::get(CI->getType(), FormatStr.size());
   }
 
@@ -2611,9 +2691,9 @@ Value *LibCallSimplifier::optimizeSnPrintFString(CallInst *CI, IRBuilder<> &B) {
         return nullptr;
       Value *V = B.CreateTrunc(CI->getArgOperand(3), B.getInt8Ty(), "char");
       Value *Ptr = castToCStr(CI->getArgOperand(0), B);
-      B.CreateStore(V, Ptr);
+      B.CreateStore(V, Ptr)->setAAMetadata(AATags);
       Ptr = B.CreateGEP(B.getInt8Ty(), Ptr, B.getInt32(1), "nul");
-      B.CreateStore(B.getInt8(0), Ptr);
+      B.CreateStore(B.getInt8(0), Ptr)->setAAMetadata(AATags);
 
       return ConstantInt::get(CI->getType(), 1);
     }
@@ -2631,7 +2711,8 @@ Value *LibCallSimplifier::optimizeSnPrintFString(CallInst *CI, IRBuilder<> &B) {
 
       B.CreateMemCpy(CI->getArgOperand(0), Align::None(), CI->getArgOperand(3),
                      Align::None(),
-                     ConstantInt::get(CI->getType(), Str.size() + 1));
+                     ConstantInt::get(CI->getType(), Str.size() + 1),
+                     false, AATags.TBAA, nullptr, AATags.Scope, AATags.NoAlias);
 
       // The snprintf result is the unincremented number of bytes in the string.
       return ConstantInt::get(CI->getType(), Str.size());
@@ -2848,9 +2929,12 @@ Value *LibCallSimplifier::optimizePuts(CallInst *CI, IRBuilder<> &B) {
 
 Value *LibCallSimplifier::optimizeBCopy(CallInst *CI, IRBuilder<> &B) {
   // bcopy(src, dst, n) -> llvm.memmove(dst, src, n)
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   return B.CreateMemMove(CI->getArgOperand(1), Align::None(),
                          CI->getArgOperand(0), Align::None(),
-                         CI->getArgOperand(2));
+                         CI->getArgOperand(2),
+                         false, AATags.TBAA, AATags.Scope, AATags.NoAlias);
 }
 
 bool LibCallSimplifier::hasFloatVersion(StringRef FuncName) {
@@ -3282,9 +3366,13 @@ FortifiedLibCallSimplifier::isFortifiedCallFoldable(CallInst *CI,
 Value *FortifiedLibCallSimplifier::optimizeMemCpyChk(CallInst *CI,
                                                      IRBuilder<> &B) {
   if (isFortifiedCallFoldable(CI, 3, 2)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     CallInst *NewCI = B.CreateMemCpy(CI->getArgOperand(0), Align::None(),
                                      CI->getArgOperand(1), Align::None(),
-                                     CI->getArgOperand(2));
+                                     CI->getArgOperand(2),
+                                     false, AATags.TBAA, AATags.TBAAStruct,
+                                     AATags.Scope, AATags.NoAlias);
     NewCI->setAttributes(CI->getAttributes());
     return CI->getArgOperand(0);
   }
@@ -3294,9 +3382,12 @@ Value *FortifiedLibCallSimplifier::optimizeMemCpyChk(CallInst *CI,
 Value *FortifiedLibCallSimplifier::optimizeMemMoveChk(CallInst *CI,
                                                       IRBuilder<> &B) {
   if (isFortifiedCallFoldable(CI, 3, 2)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     CallInst *NewCI = B.CreateMemMove(CI->getArgOperand(0), Align::None(),
                                       CI->getArgOperand(1), Align::None(),
-                                      CI->getArgOperand(2));
+                                      CI->getArgOperand(2),
+                                      false, AATags.TBAA, AATags.Scope, AATags.NoAlias);
     NewCI->setAttributes(CI->getAttributes());
     return CI->getArgOperand(0);
   }
@@ -3309,8 +3400,11 @@ Value *FortifiedLibCallSimplifier::optimizeMemSetChk(CallInst *CI,
 
   if (isFortifiedCallFoldable(CI, 3, 2)) {
     Value *Val = B.CreateIntCast(CI->getArgOperand(1), B.getInt8Ty(), false);
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     CallInst *NewCI = B.CreateMemSet(CI->getArgOperand(0), Val,
-                                     CI->getArgOperand(2), Align::None());
+                                     CI->getArgOperand(2), Align::None(),
+                                     false, AATags.TBAA, AATags.Scope, AATags.NoAlias);
     NewCI->setAttributes(CI->getAttributes());
     return CI->getArgOperand(0);
   }
@@ -3324,9 +3418,11 @@ Value *FortifiedLibCallSimplifier::optimizeStrpCpyChk(CallInst *CI,
   Value *Dst = CI->getArgOperand(0), *Src = CI->getArgOperand(1),
         *ObjSize = CI->getArgOperand(2);
 
+  AAMDNodes AATags;
+  CI->getAAMetadata(AATags);
   // __stpcpy_chk(x,x,...)  -> x+strlen(x)
   if (Func == LibFunc_stpcpy_chk && !OnlyLowerUnknownSize && Dst == Src) {
-    Value *StrLen = emitStrLen(Src, B, DL, TLI);
+    Value *StrLen = emitStrLen(Src, B, DL, TLI, AATags);
     return StrLen ? B.CreateInBoundsGEP(B.getInt8Ty(), Dst, StrLen) : nullptr;
   }
 
@@ -3337,9 +3433,9 @@ Value *FortifiedLibCallSimplifier::optimizeStrpCpyChk(CallInst *CI,
   // string lengths for varying.
   if (isFortifiedCallFoldable(CI, 2, None, 1)) {
     if (Func == LibFunc_strcpy_chk)
-      return emitStrCpy(Dst, Src, B, TLI);
+      return emitStrCpy(Dst, Src, B, TLI, AATags);
     else
-      return emitStpCpy(Dst, Src, B, TLI);
+      return emitStpCpy(Dst, Src, B, TLI, AATags);
   }
 
   if (OnlyLowerUnknownSize)
@@ -3354,7 +3450,7 @@ Value *FortifiedLibCallSimplifier::optimizeStrpCpyChk(CallInst *CI,
 
   Type *SizeTTy = DL.getIntPtrType(CI->getContext());
   Value *LenV = ConstantInt::get(SizeTTy, Len);
-  Value *Ret = emitMemCpyChk(Dst, Src, LenV, ObjSize, B, DL, TLI);
+  Value *Ret = emitMemCpyChk(Dst, Src, LenV, ObjSize, B, DL, TLI, AATags);
   // If the function was an __stpcpy_chk, and we were able to fold it into
   // a __memcpy_chk, we still need to return the correct end pointer.
   if (Ret && Func == LibFunc_stpcpy_chk)
@@ -3366,12 +3462,14 @@ Value *FortifiedLibCallSimplifier::optimizeStrpNCpyChk(CallInst *CI,
                                                        IRBuilder<> &B,
                                                        LibFunc Func) {
   if (isFortifiedCallFoldable(CI, 3, 2)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     if (Func == LibFunc_strncpy_chk)
       return emitStrNCpy(CI->getArgOperand(0), CI->getArgOperand(1),
-                               CI->getArgOperand(2), B, TLI);
+                         CI->getArgOperand(2), B, TLI, AATags);
     else
       return emitStpNCpy(CI->getArgOperand(0), CI->getArgOperand(1),
-                         CI->getArgOperand(2), B, TLI);
+                         CI->getArgOperand(2), B, TLI, AATags);
   }
 
   return nullptr;
@@ -3379,9 +3477,12 @@ Value *FortifiedLibCallSimplifier::optimizeStrpNCpyChk(CallInst *CI,
 
 Value *FortifiedLibCallSimplifier::optimizeMemCCpyChk(CallInst *CI,
                                                       IRBuilder<> &B) {
-  if (isFortifiedCallFoldable(CI, 4, 3))
+  if (isFortifiedCallFoldable(CI, 4, 3)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     return emitMemCCpy(CI->getArgOperand(0), CI->getArgOperand(1),
-                       CI->getArgOperand(2), CI->getArgOperand(3), B, TLI);
+                       CI->getArgOperand(2), CI->getArgOperand(3), B, TLI, AATags);
+  }
 
   return nullptr;
 }
@@ -3390,8 +3491,10 @@ Value *FortifiedLibCallSimplifier::optimizeSNPrintfChk(CallInst *CI,
                                                        IRBuilder<> &B) {
   if (isFortifiedCallFoldable(CI, 3, 1, None, 2)) {
     SmallVector<Value *, 8> VariadicArgs(CI->arg_begin() + 5, CI->arg_end());
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     return emitSNPrintf(CI->getArgOperand(0), CI->getArgOperand(1),
-                        CI->getArgOperand(4), VariadicArgs, B, TLI);
+                        CI->getArgOperand(4), VariadicArgs, B, TLI, AATags);
   }
 
   return nullptr;
@@ -3401,8 +3504,10 @@ Value *FortifiedLibCallSimplifier::optimizeSPrintfChk(CallInst *CI,
                                                       IRBuilder<> &B) {
   if (isFortifiedCallFoldable(CI, 2, None, None, 1)) {
     SmallVector<Value *, 8> VariadicArgs(CI->arg_begin() + 4, CI->arg_end());
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     return emitSPrintf(CI->getArgOperand(0), CI->getArgOperand(3), VariadicArgs,
-                       B, TLI);
+                       B, TLI, AATags);
   }
 
   return nullptr;
@@ -3410,53 +3515,71 @@ Value *FortifiedLibCallSimplifier::optimizeSPrintfChk(CallInst *CI,
 
 Value *FortifiedLibCallSimplifier::optimizeStrCatChk(CallInst *CI,
                                                      IRBuilder<> &B) {
-  if (isFortifiedCallFoldable(CI, 2))
-    return emitStrCat(CI->getArgOperand(0), CI->getArgOperand(1), B, TLI);
+  if (isFortifiedCallFoldable(CI, 2)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
+    return emitStrCat(CI->getArgOperand(0), CI->getArgOperand(1), B, TLI, AATags);
+  }
 
   return nullptr;
 }
 
 Value *FortifiedLibCallSimplifier::optimizeStrLCat(CallInst *CI,
                                                    IRBuilder<> &B) {
-  if (isFortifiedCallFoldable(CI, 3))
+  if (isFortifiedCallFoldable(CI, 3)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     return emitStrLCat(CI->getArgOperand(0), CI->getArgOperand(1),
-                       CI->getArgOperand(2), B, TLI);
+                       CI->getArgOperand(2), B, TLI, AATags);
+  }
 
   return nullptr;
 }
 
 Value *FortifiedLibCallSimplifier::optimizeStrNCatChk(CallInst *CI,
                                                       IRBuilder<> &B) {
-  if (isFortifiedCallFoldable(CI, 3))
+  if (isFortifiedCallFoldable(CI, 3)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     return emitStrNCat(CI->getArgOperand(0), CI->getArgOperand(1),
-                       CI->getArgOperand(2), B, TLI);
+                       CI->getArgOperand(2), B, TLI, AATags);
+  }
 
   return nullptr;
 }
 
 Value *FortifiedLibCallSimplifier::optimizeStrLCpyChk(CallInst *CI,
                                                       IRBuilder<> &B) {
-  if (isFortifiedCallFoldable(CI, 3))
+  if (isFortifiedCallFoldable(CI, 3)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     return emitStrLCpy(CI->getArgOperand(0), CI->getArgOperand(1),
-                       CI->getArgOperand(2), B, TLI);
+                       CI->getArgOperand(2), B, TLI, AATags);
+  }
 
   return nullptr;
 }
 
 Value *FortifiedLibCallSimplifier::optimizeVSNPrintfChk(CallInst *CI,
                                                         IRBuilder<> &B) {
-  if (isFortifiedCallFoldable(CI, 3, 1, None, 2))
+  if (isFortifiedCallFoldable(CI, 3, 1, None, 2)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     return emitVSNPrintf(CI->getArgOperand(0), CI->getArgOperand(1),
-                         CI->getArgOperand(4), CI->getArgOperand(5), B, TLI);
+                         CI->getArgOperand(4), CI->getArgOperand(5), B, TLI, AATags);
+  }
 
   return nullptr;
 }
 
 Value *FortifiedLibCallSimplifier::optimizeVSPrintfChk(CallInst *CI,
                                                        IRBuilder<> &B) {
-  if (isFortifiedCallFoldable(CI, 2, None, None, 1))
+  if (isFortifiedCallFoldable(CI, 2, None, None, 1)) {
+    AAMDNodes AATags;
+    CI->getAAMetadata(AATags);
     return emitVSPrintf(CI->getArgOperand(0), CI->getArgOperand(3),
-                        CI->getArgOperand(4), B, TLI);
+                        CI->getArgOperand(4), B, TLI, AATags);
+  }
 
   return nullptr;
 }
-- 
2.28.0

